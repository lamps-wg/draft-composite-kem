



LAMPS                                                       M. Ounsworth
Internet-Draft                                                   J. Gray
Intended status: Standards Track                                 Entrust
Expires: 25 March 2026                                           M. Pala
                                                             OpenCA Labs
                                                            J. Klaussner
                                                    Bundesdruckerei GmbH
                                                              S. Fluhrer
                                                           Cisco Systems
                                                       21 September 2025


      Composite ML-KEM for use in X.509 Public Key Infrastructure
                draft-ietf-lamps-pq-composite-kem-latest

Abstract

   This document defines combinations of ML-KEM [FIPS.203] in hybrid
   with traditional algorithms RSA-OAEP, ECDH, X25519, and X448.  These
   combinations are tailored to meet security best practices and
   regulatory guidelines.  Composite ML-KEM is applicable in any
   application that uses X.509 or PKIX data structures that accept ML-
   KEM, but where the operator wants extra protection against breaks or
   catastrophic bugs in ML-KEM.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at https://lamps-
   wg.github.io/draft-composite-kem/draft-ietf-lamps-pq-composite-
   kem.html.  Status information for this document may be found at
   https://datatracker.ietf.org/doc/draft-ietf-lamps-pq-composite-kem/.

   Discussion of this document takes place on the LAMPS Working Group
   mailing list (mailto:spams@ietf.org), which is archived at
   https://datatracker.ietf.org/wg/lamps/about/.  Subscribe at
   https://www.ietf.org/mailman/listinfo/spams/.

   Source for this draft and an issue tracker can be found at
   https://github.com/lamps-wg/draft-composite-kem.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 25 March 2026.

Copyright Notice

   Copyright (c) 2025 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Changes in version -08
   2.  Introduction
     2.1.  Conventions and Terminology
     2.2.  Composite Design Philosophy
   3.  Overview of the Composite ML-KEM Scheme
     3.1.  Promotion of RSA-OAEP into a KEM
     3.2.  Promotion of ECDH into a KEM
   4.  Composite ML-KEM Functions
     4.1.  Key Generation
     4.2.  Encapsulation
     4.3.  Decapsulation
     4.4.  KEM Combiner Function
   5.  Serialization
     5.1.  SerializePublicKey and DeserializePublicKey
     5.2.  SerializePrivateKey and DeserializePrivateKey
     5.3.  SerializeCiphertext and DeserializeCiphertext
   6.  Use within X.509 and PKIX
     6.1.  Encoding to DER
     6.2.  Key Usage Bits
     6.3.  ASN.1 Definitions
   7.  Algorithm Identifiers and Parameters
     7.1.  RSA-OAEP Parameters
     7.2.  Rationale for choices
   8.  ASN.1 Module
   9.  IANA Considerations
     9.1.  Object Identifier Allocations
       9.1.1.  Module Registration
       9.1.2.  Object Identifier Registrations
   10. Security Considerations
     10.1.  Why Hybrids?
     10.2.  KEM Combiner
       10.2.1.  IND-CCA Security of the hybrid scheme
       10.2.2.  Second pre-image resistance of component KEMs
       10.2.3.  SHA3 vs HMAC-SHA2
       10.2.4.  Generifying this construction
     10.3.  Key Reuse
     10.4.  Decapsulation failure
     10.5.  Policy for Deprecated and Acceptable Algorithms
   11. Implementation Considerations
     11.1.  FIPS Certification
       11.1.1.  Combiner Function
       11.1.2.  Order of KDF inputs with Non-Approved Algorithms
     11.2.  Backwards Compatibility
     11.3.  Profiling down the number of options
     11.4.  Decapsulation Requires the Public Key
   12. References
     12.1.  Normative References
     12.2.  Informative References
   Appendix A.  Maximum Key and Ciphertext Sizes
   Appendix B.  Component Algorithm Reference
   Appendix C.  Fixed Component Algorithm Identifiers
   Appendix D.  Comparison with other Hybrid KEMs
     D.1.  X-Wing
     D.2.  ETSI CatKDF
   Appendix E.  Examples of KEM Combiner Intermediate Values
   Appendix F.  Test Vectors
   Appendix G.  Intellectual Property Considerations
   Appendix H.  Contributors and Acknowledgments
   Authors' Addresses

1.  Changes in version -08

   Interop-affecting changes:

   *  Changed the private key serialization to carry the TradPK.

   *  Fixed the ASN.1 module for the pk-CompositeKEM and kema-
      CompositeKEM to indicate no ASN.1 wrapping is used.  This simply
      clarifies the intended encoding but could be an interop-affecting
      change for implementations that built encoders / decoders from the
      ASN.1 and ended up with a non-intended encoding.

   *  Changed the domain separator strings to match draft-irtf-cfrg-
      concrete-hybrid-kems-00, but no reference to it because I don't
      want this to get stuck in MISREF.

   Editorial changes:

   *  Changed the "domain separator" to "KEM Combiner Label" to match
      draft-irtf-cfrg-concrete-hybrid-kems-00, but no reference to it
      because I don't want this to get stuck in MISREF.

   Still to do in a future version:

   *  Nothing.  Authors believe this version to be complete.

2.  Introduction

   The advent of quantum computing poses a significant threat to current
   cryptographic systems.  Traditional cryptographic key establishment
   algorithms such as RSA-OAEP, Diffie-Hellman and its elliptic curve
   variants are vulnerable to quantum attacks.  During the transition to
   post-quantum cryptography (PQC), there is considerable uncertainty
   regarding the robustness of both existing and new cryptographic
   algorithms.  While we can no longer fully trust traditional
   cryptography, we also cannot immediately place complete trust in
   post-quantum replacements until they have undergone extensive
   scrutiny and real-world testing to uncover and rectify both
   algorithmic weaknesses as well as implementation flaws across all the
   new implementations.

   Unlike previous migrations between cryptographic algorithms, the
   decision of when to migrate and which algorithms to adopt is far from
   straightforward.  For instance, the aggressive migration timelines
   may require deploying PQC algorithms before their implementations
   have been fully hardened or certified, and dual-algorithm data
   protection may be desirable over a longer time period to hedge
   against CVEs and other implementation flaws in the new
   implementations.

   Cautious implementers may opt to combine cryptographic algorithms in
   such a way that an attacker would need to break all of them
   simultaneously to compromise the protected data.  These mechanisms
   are referred to as Post-Quantum/Traditional (PQ/T) Hybrids
   [I-D.ietf-pquip-pqt-hybrid-terminology].

   Certain jurisdictions are already recommending or mandating that PQC
   lattice schemes be used exclusively within a PQ/T hybrid framework.
   The use of a composite scheme provides a straightforward
   implementation of hybrid solutions compatible with (and advocated by)
   some governments and cybersecurity agencies [BSI2021], [ANSSI2024].

   This specification defines a specific instantiation of the PQ/T
   Hybrid paradigm called "composite" where multiple cryptographic
   algorithms are combined to form a single key encapsulation mechanism
   (KEM) presenting a single public key and ciphertext such that it can
   be treated as a single atomic algorithm at the protocol level; a
   property referred to as "protocol backwards compatibility" since it
   can be applied to protocols that are not explicitly hybrid-aware.
   Composite algorithms address algorithm strength uncertainty because
   the composite algorithm remains strong so long as one of its
   components remains strong.  Concrete instantiations of composite ML-
   KEM algorithms are provided based on ML-KEM, RSA-OAEP and ECDH.
   Backwards compatibility in the sense of upgraded systems continuing
   to inter-operate with legacy systems is not directly covered in this
   specification, but is the subject of Section 11.2.  The idea of a
   composite was first presented in [Bindel2017].

   Composite ML-KEM is applicable in any PKIX-related application that
   would otherwise use ML-KEM.

2.1.  Conventions and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.  These words may also appear in this
   document in lower case as plain English words, absent their normative
   meanings.

   This specification is consistent with all terminology from
   [I-D.ietf-pquip-pqt-hybrid-terminology].  In addition, the following
   terms are used in this specification:

   *ALGORITHM*: The usage of the term "algorithm" within this
   specification generally refers to any function which has a registered
   Object Identifier (OID) for use within an ASN.1 AlgorithmIdentifier.
   This loosely, but not precisely, aligns with the definitions of
   "cryptographic algorithm" and "cryptographic scheme" given in
   [I-D.ietf-pquip-pqt-hybrid-terminology].

   *COMBINER*: A combiner specifies how multiple shared secret keys are
   combined into a single shared secret key.

   *COMPONENT / PRIMITIVE*: The words "component" or "primitive" are
   used interchangeably to refer to a cryptographic algorithm that is
   used internally within a composite algorithm.  For example this could
   be an asymmetric algorithm such as "ML-KEM-768" or "RSA-OAEP", or a
   KDF such as "HMAC-SHA256".

   *DER:* Distinguished Encoding Rules as defined in [X.690].

   *KEM:* A key encapsulation mechanism as defined in Section 3.

   *PKI:* Public Key Infrastructure, as defined in [RFC5280].

   *SHARED SECRET KEY:* A value established between two communicating
   parties for use as cryptographic key material suitable for direct use
   by symmetric cryptographic algorithms.  This specification is
   concerned with shared secrets established via public key
   cryptographic operations.

   Notation: The algorithm descriptions use python-like syntax.  The
   following symbols deserve special mention:

   *  || represents concatenation of two byte arrays.

   *  [:] represents byte array slicing.

   *  (a, b) represents a pair of values a and b.  Typically this
      indicates that a function returns multiple values; the exact
      conveyance mechanism -- tuple, struct, output parameters, etc --
      is left to the implementer.

   *  (a, _): represents a pair of values where one -- the second one in
      this case -- is ignored.

   *  Func<TYPE>(): represents a function that is parametrized by <TYPE>
      meaning that the function's implementation will have minor
      differences depending on the underlying TYPE.  Typically this
      means that a function will need to look up different constants or
      use different underlying cryptographic primitives depending on
      which composite algorithm it is implementing.

2.2.  Composite Design Philosophy

   [I-D.ietf-pquip-pqt-hybrid-terminology] defines composites as:

      _Composite Cryptographic Element_: A cryptographic element that
      incorporates multiple component cryptographic elements of the same
      type in a multi-algorithm scheme.

   Composite algorithms, as defined in this specification, follow this
   definition and should be regarded as a single key that performs a
   single cryptographic operation typical of a key establishment
   mechanism such as key generation, encapsulating, or decapsulating --
   using its internal concatenation of component keys as if they form a
   single key.  This generally means that the complexity of combining
   algorithms can and should be handled by the cryptographic library or
   cryptographic module, and the single composite public key, private
   key, and ciphertext can be carried in existing fields in protocols
   such as PKCS#10 [RFC2986], CMP [RFC4210], X.509 [RFC5280], CMS
   [RFC5652], and the Trust Anchor Format [RFC5914].  In this way,
   composites achieve "protocol backwards-compatibility" in that they
   will drop cleanly into any protocol that accepts an analogous single-
   algorithm cryptographic scheme without requiring any modification of
   the protocol to handle multiple algorithms.

   Discussion of the specific choices of algorithm pairings can be found
   in Section 7.2.

3.  Overview of the Composite ML-KEM Scheme

   Composite ML-KEM is a PQ/T hybrid Key Encapsulation Mechanism (KEM)
   which combines ML-KEM as specified in [FIPS.203] and
   [I-D.ietf-lamps-kyber-certificates] with one of RSA-OAEP defined in
   [RFC8017], the Elliptic Curve Diffie-Hellman key agreement schemes
   ECDH defined in section 5.7.1.2 of [SP.800-56Ar3], and X25519 / X448
   defined in [RFC8410].  A KEM combiner function is used to combine the
   two component shared secret keys into a single shared secret key.

   Composite Key Encapsulation Mechanisms are defined as cryptographic
   primitives that consist of three algorithms.  These definitions are
   borrowed from [RFC9180].

   *  KeyGen() -> (pk, sk): A probabilistic key generation algorithm,
      which generates a public key pk and a secret key sk.  Some
      cryptographic modules may also expose a KeyGen(seed) -> (pk, sk),
      which generates pk and sk deterministically from a seed.  This
      specification assumes a seed-based keygen for ML-KEM.

   *  Encap(pk) -> (ss, ct): A probabilistic encapsulation algorithm,
      which takes as input a public key pk and outputs a ciphertext ct
      and shared secret key ss.  Note: this specification uses Encap()
      to conform to [RFC9180], but [FIPS.203] uses Encaps().

   *  Decap(sk, ct) -> ss: A decapsulation algorithm, which takes as
      input a secret key sk and ciphertext ct and outputs a shared
      secret ss, or in some cases a distinguished error value.  Note:
      this specification uses Decap() to conform to [RFC9180], but
      [FIPS.203] uses Decaps().

   The KEM interface defined above differs from both traditional key
   transport mechanism (for example for use with KeyTransRecipientInfo
   defined in [RFC5652]), and key agreement (for example for use with
   KeyAgreeRecipientInfo defined in [RFC5652]) and thus Composite ML-KEM
   MUST be used with KEMRecipientInfo defined in [RFC9629], however full
   conventions for use of Composite ML-KEM within the Cryptographic
   Message Syntax will be included in a separate specification.

   The KEM interface was chosen as the interface for a composite key
   establishment because it allows for arbitrary combinations of
   component algorithm types since both key transport and key agreement
   mechanisms can be promoted into KEMs as described in Section 3.1 and
   Section 3.2 below.

   The following algorithms are defined for serializing and
   deserializing component values.  These algorithms are inspired by
   similar algorithms in [RFC9180].

   *  SerializePublicKey(mlkemPK, tradPK) -> bytes: Produce a byte
      string encoding of the component public keys.

   *  DeserializePublicKey(bytes) -> (mlkemPK, tradPK): Parse a byte
      string to recover the component public keys.

   *  SerializeCiphertext(mlkemCT, tradCT) -> bytes: Produce a byte
      string encoding of the component ciphertexts.

   *  DeserializeCiphertext(bytes) -> (mlkemCT, tradCT): Parse a byte
      string to recover the component ciphertexts.

   *  SerializePrivateKey(mlkemSeed, tradPK, tradSK) -> bytes: Produce a
      byte string encoding of the component private keys.

   *  DeserializePrivateKey(bytes) -> (mlkemSeed, tradPK, tradSK): Parse
      a byte string to recover the component private keys.

   Full definitions of serialization and deserialization algorithms can
   be found in Section 5.

3.1.  Promotion of RSA-OAEP into a KEM

   The RSA Optimal Asymmetric Encryption Padding (OAEP), as defined in
   section 7.1 of [RFC8017] is a public key encryption algorithm used to
   transport key material from a sender to a receiver.  A "key
   transport" type algorithm has the following API:

   *  Encrypt(pk, ss) -> ct: Take an existing shared secret key ss and
      encrypt it for pk.

   *  Decrypt(sk, ct) -> ss: Decrypt the ciphertext ct to recover ss.

   Note the difference between the API of RSA.Encrypt(pk, ss) -> ct and
   KEM.Encap(pk) -> (ss, ct) presented above.  For this reason, RSA-OAEP
   cannot be directly combined with ML-KEM.  Fortunately, a key
   transport mechanism such as RSA-OAEP can be easily promoted into a
   KEM by having the sender generate a random 256 bit shared secret key
   and encrypt it.

   RSAOAEPKEM.Encap(pkR):
     shared_secret = SecureRandom(ss_len)
     enc = RSAES-OAEP-ENCRYPT(pkR, shared_secret)

     return shared_secret, enc

   Acceptable public key encodings for pkR are described in Section 5.

   Note that the OAEP label L is left to its default value, which is the
   empty string as per [RFC8017].  The shared secret key output by the
   overall Composite ML-KEM already binds a composite KEM Combiner
   Label, so there is no need to also use the component Label.

   The value of ss_len as well as concrete values for all the RSA-OAEP
   parameters used within this specification can be found in
   Section 7.1.

   Decap(sk, ct) -> ss is accomplished by direct use of OAEP Decrypt.

   RSAOAEPKEM.Decap(skR, enc):
     shared_secret = RSAES-OAEP-DECRYPT(skR, enc)

     return shared_secret

   A quick note on the choice of RSA-OAEP as the supported RSA
   encryption primitive.  RSA-KEM [RFC5990] is cryptographically robust
   and is more straightforward to work with, but it has fairly limited
   adoption and therefore is of limited value as a PQ migration
   mechanism.  Also, while RSA-PKCS#1v1.5 [RFC8017] is still widely
   used, it is hard to make secure and no longer FIPS-approved as of the
   end of 2023 [SP800-131Ar2], so it is of limited forwards value.  This
   leaves RSA-OAEP [RFC8017] as the remaining choice.  See Section 7.2
   for further discussion of algorithm choices.

   Note that, at least at the time of writing, the algorithm RSAOAEPKEM
   is not defined as a standalone algorithm within PKIX standards and it
   does not have an assigned algorithm OID, so it cannot be used
   directly with CMS KEMRecipientInfo [RFC9629]; it is merely a building
   block for the composite algorithm.

3.2.  Promotion of ECDH into a KEM

   The elliptic curve Diffie-Hellman algorithm identified by the OID id-
   ecDH as defined in [RFC5480] and [SEC1] is a key agreement algorithm
   requiring both parties to contribute an asymmetric keypair to the
   derivation of the shared secret key.  A "key agreement" type
   algorithm has the following API:

   *  DH(skX, pkY) -> ss: Each party combines their secret key skX with
      the other party's public key pkY.

   Note the difference between the API of DH(skX, pkY) -> ss and
   KEM.Encap(pk) -> (ss, ct) presented above.  For this reason, a
   Diffie-Hellman key exchange cannot be directly combined with ML-KEM.
   Fortunately, a Diffie-Hellman key agreement can be easily promoted
   into a KEM Encap(pk) -> (ss, ct) by having the sender generate an
   ephemeral keypair for themself and sending their public key as the
   ciphertext ct.  Composite ML-KEM uses a simplified version of the
   DHKEM definition from [RFC9180]:

   DHKEM.Encap(pkR):
     (skE, pkE) = GenerateKeyPair()
     ss = DH(skE, pkR)
     ct = SerializePublicKey(pkE)

     return ss, ct

   Decap(sk, ct) -> ss is accomplished in the analogous way.

   DHKEM.Decap(skR, ct):
     pkE = DeserializePublicKey(ct)
     ss = DH(skR, pkE)

     return ss

   This construction applies for all variants of elliptic curve Diffie-
   Hellman used in this specification: ECDH, X25519, and X448.

   For ECDH, DH() yields the value Z as described in section 5.7.1.2 of
   [SP.800-56Ar3].  Acceptable public key encodings for enc and pkE are
   described in Section 5.

   For X25519 and X448, DH() yields the value K as described in section
   6 of [RFC7748].  Acceptable public key encodings for enc and pkE are
   described in Section 5.

   The promotion of DH to a KEM is similar to the DHKEM functions in
   [RFC9180], but it is simplified in the following ways:

   1.  Notation has been aligned to the notation used in this
       specification.

   2.  Since a KEM Combiner Label is included explicitly in the
       Composite ML-KEM combiner, there is no need to perform the
       labeled steps of ExtractAndExpand().

   3.  Since the ciphertext and receiver's public key are included
       explicitly in the Composite ML-KEM combiner, there is no need to
       construct the kem_context object.

   Note that here, SerializePublicKey() and DeserializePublicKey() refer
   to the underlying encoding of the DH primitive, and not to the
   composite serialization functions defined in Section 5.  Acceptable
   serializations for the underlying DH primitives are described in
   Section 5.

   Note that, at least at the time of writing, the algorithm DHKEM is
   not defined as a standalone algorithm within PKIX standards and it
   does not have an assigned algorithm OID, so it cannot be used
   directly with CMS KEMRecipientInfo [RFC9629]; it is merely a building
   block for the composite algorithm.

4.  Composite ML-KEM Functions

   This section describes the composite ML-KEM functions needed to
   instantiate the public API of a Key Encapsulation Mechanism as
   defined in Section 3.

4.1.  Key Generation

   In order to maintain security properties of the composite,
   applications that use composite keys MUST always perform fresh key
   generations of both component keys and MUST NOT reuse existing key
   material.  See Section 10.3 for a discussion.

   To generate a new keypair for composite schemes, the KeyGen() -> (pk,
   sk) function is used.  The KeyGen() function calls the two key
   generation functions of the component algorithms independently.
   Multi-threaded, multi-process, or multi-module applications might
   choose to execute the key generation functions in parallel for better
   key generation performance or architectural modularity.

   The following describes how to instantiate a KeyGen() function for a
   given composite algorithm represented by <OID>.

   Composite-ML-KEM<OID>.KeyGen() -> (pk, sk)

   Explicit Inputs:
        None

   Implicit Inputs mapped from <OID>:

     ML-KEM     The underlying ML-KEM algorithm and
                parameter set, for example, could be "ML-KEM-768".

     Trad       The underlying traditional algorithm and
                parameter, for example "RSA-OAEP"
                or "X25519".

   Output:
     (pk, sk)  The composite keypair.

   Key Generation Process:

     1. Generate component keys

       mlkemSeed = Random(64)
       (mlkemPK, mlkemSK) = ML-KEM.KeyGen(mlkemSeed)
       (tradPK, tradSK) = Trad.KeyGen()

     2. Check for component key gen failure
       if NOT (mlkemPK, mlkemSK) or NOT (tradPK, tradSK):
         output "Key generation error"

     3. Output the composite public and private keys

       pk = SerializePublicKey(mlkemPK, tradPK)
       sk = SerializePrivateKey(mlkemSeed, tradPK, tradSK)
       return (pk, sk)

   In order to ensure fresh keys, the key generation functions MUST be
   executed for both component algorithms.  Compliant parties MUST NOT
   use, import or export component keys that are used in other contexts,
   combinations, or by themselves as keys for standalone algorithm use.
   For more details on the security considerations around key reuse, see
   Section 10.3.

   Note that this keygen routine outputs a serialized composite key,
   which contains only the ML-KEM seed.  Implementations should feel
   free to modify this routine to output the expanded mlkemSK or to make
   free use of ML-KEM.KeyGen(mldsaSeed) as needed to expand the ML-KEM
   seed into an expanded prior to performing a decapsulation operation.

   Variations in the keygen process above and decapsulation processes
   below to accommodate particular private key storage mechanisms or
   alternate interfaces to the underlying cryptographic modules are
   considered to be conformant to this specification so long as they
   produce the same output and error handling.  For example, component
   private keys stored in separate software or hardware modules where it
   is not possible to do a joint simultaneous keygen would be considered
   compliant so long as both keys are freshly generated.  It is also
   possible that the underlying cryptographic module does not expose a
   ML-KEM.KeyGen(seed) that accepts an externally-generated seed, and
   instead an alternate keygen interface must be used.  Note however
   that cryptographic modules that do not support seed-based ML-KEM key
   generation will be incapable of importing or exporting composite keys
   in the standard format since the private key serialization routines
   defined in Section 5.2 only support ML-KEM keys as seeds.

4.2.  Encapsulation

   The Encap(pk) of a Composite ML-KEM algorithm is designed to behave
   exactly the same as ML-KEM.Encaps(ek) defined in Algorithm 20 in
   Section 7.2 of [FIPS.203].  Specifically, Composite-ML-KEM.Encap(pk)
   produces a 256-bit shared secret key that can be used directly with
   any symmetric-key cryptographic algorithm.  In this way, Composite
   ML-KEM can be used as a direct drop-in replacement anywhere that ML-
   KEM is used.

   The following describes how to instantiate a Encap(pk) function for a
   given composite algorithm represented by <OID>.

   Composite-ML-KEM<OID>.Encap(pk) -> (ss, ct)

   Explicit Inputs:

     pk      Composite public key consisting of encryption public keys
             for each component.

   Implicit inputs mapped from <OID>:

     ML-KEM  The underlying ML-KEM algorithm and
             parameter set, for example "ML-KEM-768".

     Trad    The underlying ML-KEM algorithm and
             parameter set, for example "RSA-OAEP"
             or "X25519".

     KDF     The KDF specified for the given Composite ML-KEM algorithm.
             See algorithm specifications below.

     Label   KEM Combiner Label value for binding the ciphertext to the
             Composite OID. See section on KEM Combiner Labels below.

   Output:

     ss      The shared secret key, a 256-bit key suitable for use with
             symmetric cryptographic algorithms.

     ct      The ciphertext, a byte string.

   Encap Process:

     1. Separate the public keys.

         (mlkemPK, tradPK) = DeserializePublicKey(pk)

     2.  Perform the respective component Encap operations according to
         their algorithm specifications.

         (mlkemCT, mlkemSS) = ML-KEM.Encaps(mlkemPK)
         (tradCT, tradSS) = TradKEM.Encap(tradPK)

     3. If either ML-KEM.Encaps() or TradKEM.Encap() return an error,
        then this process must return an error.

         if NOT (mlkemCT, mlkemSS) or NOT (tradCT, tradSS):
           output "Encapsulation error"

     4. Encode the ciphertext

         ct = SerializeCiphertext(mlkemCT, tradCT)

     5. Combine the KEM secrets and additional context to yield the
        composite shared secret key.

           ss = KemCombiner<KDF>(mlkemSS, tradSS, tradCT, tradPK, Label)

     6. Output composite shared secret key and ciphertext.

        return (ss, ct)

   Depending on the security needs of the application, it MAY be
   advantageous to perform steps 2, 3, and 5 in a timing-invariant way
   to prevent side-channel attackers from learning which component
   algorithm failed and from learning any of the inputs or output of the
   KEM combiner.

   The specific values for KDF and the specific values for Label are
   defined per Composite ML-KEM algorithm in Section 7.

4.3.  Decapsulation

   The Decap(sk, ct) -> ss of a Composite ML-KEM algorithm is designed
   to behave exactly the same as ML-KEM.Decaps(dk, c) defined in
   Algorithm 21 in Section 7.3 of [FIPS.203].  Specifically, Composite-
   ML-KEM.Decap(sk, ct) produces a 256-bit shared secret key that can be
   used directly with any symmetric-key cryptographic algorithm.  In
   this way, Composite ML-KEM can be used as a direct drop-in
   replacement anywhere that ML-KEM is used.

   The following describes how to instantiate a Decap(sk, ct) function
   for a given composite algorithm represented by <OID>.

   Composite-ML-KEM<OID>.Decap(sk, ct) -> ss

   Explicit inputs

     sk      Composite private key consisting of decryption private
             keys for each component.

     ct      The ciphertext, a byte string.

   Implicit inputs mapped from <OID>:

     ML-KEM  The underlying ML-KEM algorithm and
             parameter set, for example, could be "ML-KEM-768".

     Trad    The underlying traditional algorithm and
             parameter set, for example "RSA-OAEP"
             or "X25519".

     tradPK  The traditional public key is required for the KEM
             combiner.
             The suggested algorithm below extracts the tradPK
             from sk, however implementations that use a non-standard
             private key encoding will need to obtain the traditional
             public key some other way.

     KDF     The KDF specified for the given Composite ML-KEM
             algorithm. See algorithm specifications below.

     Label   KEM Combiner Label value for binding the ciphertext to
             the Composite ML-KEM OID.
             See section on KEM Combiner Labels below.

   Output:

     ss      The shared secret key, a 256-bit key suitable for use
             with symmetric cryptographic algorithms.

   Decap Process:

     1. Separate the private keys and ciphertexts

         (mlkemSeed, tradPK, tradSK) = DeserializePrivateKey(sk)
         (_, mlkemSK) = ML-KEM.KeyGen(mlkemSeed)
         (mlkemCT, tradCT) = DeserializeCiphertext(ct)

     2.  Perform the respective component Encap operations according
         to their algorithm specifications.

         mlkemSS = ML-KEM.Decaps(mlkemSK, mlkemCT)
         tradSS  = TradKEM.Decap(tradSK, tradCT)

     3. If either ML-KEM.Decaps() or TradKEM.Decap() return an error,
        then this process must return an error.

         if NOT mlkemSS or NOT tradSS:
           output "Encapsulation error"

     4. Combine the KEM secrets and additional context to yield the
        composite shared secret key.

         ss = KemCombiner<KDF>(mlkemSS, tradSS, tradCT, tradPK, Label)

     5. Output composite shared secret key.

        return ss

   Steps 2, 3, and 4 SHOULD be performed in a timing-invariant way to
   prevent side-channel attackers from learning which component
   algorithm failed and from learning any of the inputs or output of the
   KEM combiner.

   It is possible to use component private keys stored in separate
   software or hardware keystores.  Variations in the process to
   accommodate particular private key storage mechanisms are considered
   to be conformant to this specification so long as it produces the
   same output and error handling as the process sketched above.

   In order to properly achieve its security properties, the KEM
   combiner requires that all inputs are fixed-length.  Since each
   Composite ML-KEM algorithm fully specifies its component algorithms,
   including key sizes, all inputs should be fixed-length in non-error
   scenarios except for minor variations introduced by encoding.
   However some implementations may choose to perform additional
   checking to handle certain error conditions.  In particular, the KEM
   combiner step should not be performed if either of the component
   decapsulations returned an error condition indicating malformed
   inputs.  For timing-invariance reasons, it is RECOMMENDED to perform
   both decapsulation operations and check for errors afterwards to
   prevent an attacker from using a timing channel to tell which
   component failed decapsulation.  Also, RSA-based composites MUST
   ensure that the modulus size (i.e. the size of tradCT and tradPK)
   matches that specified for the given Composite ML-KEM algorithm in
   Section 7; depending on the cryptographic library used, this check
   may be done by the library or may require an explicit check as part
   of the Composite-ML-KEM.Decap() routine.  Implementers should keep in
   mind that some instances of tradCT and tradPK will be DER-encoded
   which could introduce minor length variations such as dropping
   leading zeroes; since these variations are not attacker-controlled
   they are considered benign.

4.4.  KEM Combiner Function

   As noted in the Encapsulation and Decapsulation procedures above, the
   KEM combiner is parameterized by the choice of underlying KDF.  This
   specification provides two combiner constructions, one with SHA3 and
   one with HMAC-SHA2.

   The following describes how to instantiate a KemCombiner() function
   for a given key derivation function represented by <KDF>.

  KemCombiner<KDF>(mlkemSS, tradSS, tradCT, tradPK, Label) -> ss

  Explicit inputs:

    The list of input values to be combined.

  Implicit inputs:

    KDF      The KDF specified for the given Composite ML-KEM algorithm.
             In particular, for the KEM combiner it only matters
             whether this is a SHA3 function, which can be used
             as a KDF directly, or a SHA2 function which requires
             an HMAC construction.

  Output:

    ss      The shared secret key, a 256-bit key suitable for use with
            symmetric cryptographic algorithms.


  Process:

    if KDF is "SHA3-256":
      ss = SHA3-256(mlkemSS || tradSS || tradCT || tradPK || Label)

    else if KDF is "HMAC-{Hash}":

      ss = HMAC-{Hash}(key={0}, text=mlkemSS || tradSS || tradCT
                                             || tradPK || Label)
      ss = truncate(ss, 256)
          # Where "{0}" is the string of HashLen zeros according to
          # section 2.2 of [RFC5869].

          # Where "{Hash} is the underlying hash function used
          # for the given composite algorithm.

          # Since Composite ML-KEM always outputs a 256-bit shared
          # secret key, the output is always truncated to 256 bits,
          # regardless of underlying hash function.

    return ss

   Implementation note: The HMAC-based combiner here is exactly the
   "HKDF-Extract" step from [RFC5869] with an empty salt.
   Implementations with access to "HKDF-Extract", without the "HKDF-
   Expand" step, MAY use this interchangeably with the HMAC-based
   construction presented above.  Note that a full invocation of HKDF
   with both HKDF-Extract and HKDF-Expand, even with the correct output
   length and empty info param is not equivalent to the HMAC
   construction above since HKDF-Expand will always perform at least one
   extra iteration of HMAC.

5.  Serialization

   This section presents routines for serializing and deserializing
   composite public keys, private keys, and ciphertext values to bytes
   via simple concatenation of the underlying encodings of the component
   algorithms.  The functions defined in this section are considered
   internal implementation detail and are referenced from within the
   public API definitions in Section 4.

   Deserialization is possible because ML-KEM has fixed-length public
   keys, private keys (seeds), and ciphertext values as shown in the
   following table.

          +=============+============+=============+============+
          | Algorithm   | Public Key | Private Key | Ciphertext |
          +=============+============+=============+============+
          | ML-KEM-768  | 1184       | 64          | 1088       |
          +-------------+------------+-------------+------------+
          | ML-KEM-1024 | 1568       | 64          | 1568       |
          +-------------+------------+-------------+------------+

                                  Table 1

   For all serialization routines below, when these values are required
   to be carried in an ASN.1 structure, they are wrapped as described in
   Section 6.1.

   While ML-KEM has a single fixed-size representation for each of
   public key, private key, and ciphertext, the traditional component
   might allow multiple valid encodings; for example an elliptic curve
   public key, and therefore also ciphertext, might be validly encoded
   as either compressed or uncompressed [SEC1], or an RSA private key
   could be encoded in Chinese Remainder Theorem form [RFC8017].  In
   order to obtain interoperability, composite algorithms MUST use the
   following encodings of the underlying components:

   *  *ML-KEM*: MUST be encoded as specified in [FIPS.203], using a
      64-byte seed as the private key.

   *  *RSA*: the public key MUST be encoded as RSAPublicKey with the
      (n,e) public key representation as specified in A.1.1 of [RFC8017]
      and the private key representation as RSAPrivateKey specified in
      A.1.2 of [RFC8017] with version 0 and 'otherPrimeInfos' absent.

   *  *ECDH*: public key MUST be encoded as an ECPoint as specified in
      section 2.2 of [RFC5480], with both compressed and uncompressed
      keys supported.  For maximum interoperability, it is RECOMMENEDED
      to use uncompressed points.  The private key must be encoded as
      ECPrivateKey specified in [RFC5915] without 'NamedCurve' parameter
      and without 'publicKey' field.

   *  *X25519 and X448*: the public key MUST be encoded as per section 5
      of [RFC7748] and the private key as CurvePrivateKey specified in
      [RFC8410].

   All ASN.1 objects SHALL be encoded using DER on serialization.

   Even with fixed encodings for the traditional component, there may be
   slight differences in size of the encoded value due to, for example,
   encoding rules that drop leading zeroes.  See Appendix A for further
   discussion of encoded size of each composite algorithm.

   The deserialization routines described below do not check for well-
   formedness of the cryptographic material they are recovering.  It is
   assumed that underlying cryptographic primitives will catch malformed
   values and raise an appropriate error.

5.1.  SerializePublicKey and DeserializePublicKey

   The serialization routine for keys simply concatenates the public
   keys of the component algorithms, as defined below:

   Composite-ML-KEM.SerializePublicKey(mlkemPK, tradPK) -> bytes

   Explicit inputs:

     mlkemPK The ML-KEM public key, which is bytes.

     tradPK  The traditional public key in the appropriate
             encoding for the underlying component algorithm.

   Implicit inputs:

     None

   Output:

     bytes   The encoded composite public key.


   Serialization Process:

     1. Combine and output the encoded public key

        output mlkemPK || tradPK

   Deserialization reverses this process.  Each component key is
   deserialized according to their respective specification as shown in
   Appendix B.

   The following describes how to instantiate a
   DeserializePublicKey(bytes) function for a given composite algorithm
   represented by <OID>.

  Composite-ML-KEM<OID>.DeserializePublicKey(bytes) -> (mlkemPK, tradPK)

  Explicit inputs:

    bytes   An encoded composite public key.

  Implicit inputs mapped from <OID>:

    ML-KEM   The underlying ML-KEM algorithm and
             parameter, for example, could be "ML-KEM-768".

  Output:

    mlkemPK  The ML-KEM public key, which is bytes.

    tradPK   The traditional public key in the appropriate
             encoding for the underlying component algorithm.


  Deserialization Process:

    1. Parse each constituent encoded public key.
         The length of the mlkemPK is known based on the size of
         the ML-KEM component key length specified by the Object ID.

       switch ML-KEM do
          case ML-KEM-768:
            mlkemPK = bytes[:1184]
            tradPK  = bytes[1184:]
          case ML-KEM-1024:
            mlkemPK = bytes[:1568]
            tradPK  = bytes[1568:]

       Note that while ML-KEM has fixed-length keys, RSA and ECDH
       may not, depending on encoding, so rigorous length-checking
       of the overall composite key is not always possible.

    2. Output the component public keys

       output (mlkemPK, tradPK)

5.2.  SerializePrivateKey and DeserializePrivateKey

   The serialization routine for keys simply concatenates the private
   keys of the component algorithms, as defined below:

   Composite-ML-KEM.SerializePrivateKey(mlkemSeed, tradPK, tradSK)
                                     -> bytes

   Explicit inputs:

     mlkemSeed  The ML-KEM private key, which is the bytes of the seed.

     tradPK     The traditional public key in the appropriate
                encoding for the underlying component algorithm.
                This is required by the decapsulater for inclusion
                in the KEM combiner.

     tradSK     The traditional private key in the appropriate
                encoding for the underlying component algorithm.

   Implicit inputs:

     None

   Output:

     bytes   The encoded composite private key.

   Serialization Process:

     1. Compute the length of tradPK

        lenTradPK = IntegerToBytes( len(tradPK), 2 )

     2. Combine and output the encoded private key.

        output mlkemSeed || lenTradPK || tradPK || tradSK

   The function IntegerToBytes(x, a) is defined in Algorithm 11 of
   [FIPS.204], which is the usual little-endian encoding of an integer.
   Encoding to 2 bytes allows for traditional public keys up to 65 kb.

   Deserialization reverses this process.  Each component key is
   deserialized according to their respective specification as shown in
   Appendix B.

   The following describes how to instantiate a
   DeserializePrivateKey(bytes) function.  Since ML-KEM private keys are
   64 bytes for all parameter sets, this function does not need to be
   parametrized.

   Composite-ML-KEM.DeserializePrivateKey(bytes)
                                       -> (mlkemSeed, tradPK, tradSK)

   Explicit inputs:

     bytes   An encoded composite private key.

   Implicit inputs:

     That an ML-KEM private key is 64 bytes for all parameter sets.

   Output:

     mlkemSeed  The ML-KEM private key, which is the bytes of the seed.

     tradSK    The traditional private key in the appropriate
                encoding for the underlying component algorithm.


   Deserialization Process:

     1. Parse the ML-DSA seed, which is always a 64 byte seed
        for all parameter sets.

        mlkemSeed = bytes[:64]


     2. Parse the traditional public and private key

        lenTradPK = BytesToInteger( bytes[64:66] )
        tradPK = bytes[66: 66+lenTradPK]

        tradSK  = bytes[66+lenTradPK:]

        Note that while ML-KEM has fixed-length keys, RSA and ECDH
        may not, depending on encoding, so rigorous length-checking
        of the overall composite key is not always possible.

     2. Output the component private keys

        output (mlkemSeed, tradPK, tradSK)

   The function BytesToInteger(x) is not defined in [FIPS.204], but is
   the obvious inverse of the defined IntegerToBytes() which is the
   usual little-endian encoding of an integer.

5.3.  SerializeCiphertext and DeserializeCiphertext

   The serialization routine for the composite ciphertext value simply
   concatenates the fixed-length ML-KEM ciphertext with the ciphertext
   from the traditional algorithm, as defined below:

   Composite-ML-KEM.SerializeCiphertext(mlkemCT, tradCT) -> bytes

   Explicit inputs:

     mlkemCT  The ML-KEM ciphertext, which is bytes.

     tradCT   The traditional ciphertext in the appropriate
              encoding for the underlying component algorithm.

   Implicit inputs:

     None

   Output:

     bytes   The encoded composite ciphertext value.


   Serialization Process:

     1. Combine and output the encoded composite ciphertext

        output mlkemCT || tradCT

   Deserialization reverses this process.  Each component ciphertext is
   deserialized according to their respective specification as shown in
   Appendix B.

   The following describes how to instantiate a
   DeserializeCiphertext(bytes) function for a given composite algorithm
   represented by <OID>.

   Composite-ML-KEM<OID>.DeserializeCiphertext(bytes)
                                             -> (mldkemCT, tradCT)

   Explicit inputs:

     bytes   An encoded composite ciphertext value.

   Implicit inputs mapped from <OID>:

     ML-KEM   The underlying ML-KEM algorithm and
              parameter, for example, could be "ML-KEM-768".

   Output:

     mlkemCT  The ML-KEM ciphertext, which is bytes.

     tradCT   The traditional ciphertext in the appropriate
              encoding for the underlying component algorithm.


   Deserialization Process:

     1. Parse each constituent encoded ciphertext.
        The length of the mlkemCT is known based on the size of the
        ML-KEM component ciphertext length specified by the Object ID.

        switch ML-KEM do
           case ML-KEM-768:
             mlkemCT = bytes[:1088]
             tradCT  = bytes[1088:]
           case ML-KEM-1024:
             mlkemCT= bytes[:1568]
             tradCT  = bytes[1568:]

        Note that while ML-KEM has fixed-length ciphertexts, RSA and
        ECDH may not, depending on encoding, so rigorous length-checking
        is not always possible here.

     2. Output the component ciphertext values

        output (mlkemCT, tradCT)

6.  Use within X.509 and PKIX

   The following sections provide processing logic and the necessary
   ASN.1 modules necessary to use composite ML-KEM within X.509 and PKIX
   protocols.  Use within the Cryptographic Message Syntax (CMS) will be
   covered in a separate specification.

   While composite ML-KEM keys and ciphertext values MAY be used raw,
   the following sections provide conventions for using them within
   X.509 and other PKIX protocols such that Composite ML-KEM can be used
   as a drop-in replacement for KEM algorithms in PKCS#10 [RFC2986], CMP
   [RFC4210], X.509 [RFC5280], and related protocols.

6.1.  Encoding to DER

   The serialization routines presented in Section 5 produce raw binary
   values.  When these values are required to be carried within a DER-
   encoded message format such as an X.509's subjectPublicKey and
   signatureValue BIT STRING [RFC5280] or a OneAsymmetricKey.privateKey
   OCTET STRING [RFC5958], then the BIT STRING or OCTET STRING contains
   this raw byte string encoding of the public key.

   When a Composite ML-KEM public key appears outside of a
   SubjectPublicKeyInfo type in an environment that uses ASN.1 encoding,
   it could be encoded as an OCTET STRING by using the Composite-ML-KEM-
   PublicKey type defined below.

   Composite-ML-KEM-PublicKey ::= OCTET STRING

   Size constraints MAY be enforced, as appropriate as per Appendix A.

6.2.  Key Usage Bits

   When any Composite ML-KEM Object Identifier appears within the
   SubjectPublicKeyInfo.AlgorithmIdentifier field of an X.509
   certificate [RFC5280], the key usage certificate extension MUST only
   contain:

   keyEncipherment

   Composite ML-KEM keys MUST NOT be used in a "dual usage" mode because
   even if the traditional component key supports both signing and
   encryption, the post-quantum algorithms do not and therefore the
   overall composite algorithm does not.  Implementations MUST NOT use
   one component of the composite for the purposes of digital signature
   and the other component for the purposes of encryption or key
   establishment.

6.3.  ASN.1 Definitions

   Composite ML-KEM uses a substantially non-ASN.1 based encoding, as
   specified in Section 5.  However, as composite algorithms will be
   used within ASN.1-based X.509 and PKIX protocols, some conventions
   for ASN.1 wrapping are necessary.

   The following ASN.1 Information Object Classes are defined to allow
   for compact definitions of each composite algorithm, leading to a
   smaller overall ASN.1 module.

   pk-CompositeKEM {OBJECT IDENTIFIER:id}
     PUBLIC-KEY ::= {
       IDENTIFIER id
       -- KEY without ASN.1 wrapping --
       PARAMS ARE absent
       CERT-KEY-USAGE { keyEncipherment }
     }

   kema-CompositeKEM {
     OBJECT IDENTIFIER:id,
       PUBLIC-KEY:publicKeyType }
       KEM-ALGORITHM ::= {
            IDENTIFIER id
            -- VALUE without ASN.1 wrapping --
            PARAMS ARE absent
            PUBLIC-KEYS { publicKeyType }
            SMIME-CAPS { IDENTIFIED BY id }
           }

      Figure 1: ASN.1 Object Information Classes for Composite ML-KEM

   As an example, the public key and KEM algorithm types associated with
   id-MLKEM768-ECDH-P256-HMAC-SHA256 are defined as:

   pk-MLKEM768-ECDH-P256-HMAC-SHA256 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-ECDH-P256-HMAC-SHA256 }

   kema-MLKEM768-ECDH-P256-HMAC-SHA256 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-ECDH-P256-HMAC-SHA256,
         pk-MLKEM768-ECDH-P256-HMAC-SHA256 }

   The full set of key types defined by this specification can be found
   in the ASN.1 Module in Section 8.

   Use cases that require an interoperable encoding for composite
   private keys will often need to place a composite private key inside
   a OneAsymmetricKey structure defined in [RFC5958], such as when
   private keys are carried in PKCS #12 [RFC7292], CMP [RFC4210] or CRMF
   [RFC4211].  The definition of OneAsymmetricKey is copied here for
   convenience:

    OneAsymmetricKey ::= SEQUENCE {
          version                   Version,
          privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
          privateKey                PrivateKey,
          attributes            [0] Attributes OPTIONAL,
          ...,
          [[2: publicKey        [1] PublicKey OPTIONAL ]],
          ...
        }

     ...
     PrivateKey ::= OCTET STRING
                           -- Content varies based on type of key.  The
                           -- algorithm identifier dictates the format of
                           -- the key.

             Figure 2: OneAsymmetricKey as defined in [RFC5958]

   When a composite private key is conveyed inside a OneAsymmetricKey
   structure (version 1 of which is also known as PrivateKeyInfo)
   [RFC5958], the privateKeyAlgorithm field SHALL be set to the
   corresponding composite algorithm identifier defined according to
   Section 7 and its parameters field MUST be absent.  The privateKey
   field SHALL contain the OCTET STRING representation of the serialized
   composite private key as per Section 5.2.  The publicKey field
   remains OPTIONAL.  If the publicKey field is present, it MUST be a
   composite public key as per Section 5.1.

   Some applications might need to reconstruct the SubjectPublicKeyInfo
   or OneAsymmetricKey objects corresponding to each component key
   individually, for example if this is required for invoking the
   underlying primitive.  Section 7 provides the necessary mapping
   between composite and their component algorithms for doing this
   reconstruction.

   Component keys of a composite private key MUST NOT be used in any
   other type of key or as a standalone key.  For more details on the
   security considerations around key reuse, see Section 10.3.

7.  Algorithm Identifiers and Parameters

   This section lists the algorithm identifiers and parameters for all
   Composite ML-KEM algorithms.

   Full specifications for the referenced algorithms can be found in
   Appendix B.

   As the number of algorithms can be daunting to implementers, see
   Section 11.3 for a discussion of choosing a subset to support.

   Each Composite ML-KEM algorithm has a unique Label which is used in
   constructing the KEM combiner in (Section 4.4).  This helps protect
   against a different algorithm arriving at the same shared secret key
   even if all inputs are the same.

   Label values are provided as ASCII strings, but MUST be converted
   into binary strings in the obvious way.  For example:

   *  ".//^" in hexadecimal is "5c2e2f2f5e5c"

   *  "QSF-MLKEM768-P256-HMACSHA256" in hexadecimal is
      "5153462d4d4c4b454d3736382d503235362d484d4143534841323536"

   EDNOTE: the OIDs listed below are prototyping OIDs defined in
   Entrust's 2.16.840.1.114027.80.9.1 arc but will be replaced by IANA.

   Composite KEM algorithm list:

   *  id-MLKEM768-RSA2048-HMAC-SHA256

      -  OID: 2.16.840.1.114027.80.5.2.50

      -  Label: "QSF-MLKEM768-RSAOAEP2048-HMACSHA256"

      -  Key Derivation Function (KDF): HMAC-SHA256

      -  ML-KEM variant: ML-KEM-768

      -  Traditional Algorithm: RSA

         o  Traditional KEM Algorithm: id-RSAES-OAEP

         o  RSA size: 2048

         o  RSAES-OAEP parameters: See Table 2

   *  id-MLKEM768-RSA3072-HMAC-SHA256

      -  OID: 2.16.840.1.114027.80.5.2.51

      -  Label: "QSF-MLKEM768-RSAOAEP3072-HMACSHA256"

      -  Key Derivation Function (KDF): HMAC-SHA256

      -  ML-KEM variant: ML-KEM-768

      -  Traditional Algorithm: RSA

         o  Traditional KEM Algorithm: id-RSAES-OAEP

         o  RSA size: 3072

         o  RSAES-OAEP parameters: See Table 2

   *  id-MLKEM768-RSA4096-HMAC-SHA256

      -  OID: 2.16.840.1.114027.80.5.2.52

      -  Label: "QSF-MLKEM768-RSAOAEP4096-HMACSHA256"

      -  Key Derivation Function (KDF): HMAC-SHA256

      -  ML-KEM variant: ML-KEM-768

      -  Traditional Algorithm: RSA

         o  Traditional KEM Algorithm: id-RSAES-OAEP

         o  RSA size: 4096

         o  RSAES-OAEP parameters: See Table 2

   *  id-MLKEM768-X25519-SHA3-256

      -  OID: 2.16.840.1.114027.80.5.2.53

      -  Label: "\.//^\"

      -  Key Derivation Function (KDF): SHA3-256

      -  ML-KEM variant: ML-KEM-768

      -  Traditional Algorithm: X25519

         o  Traditional KEM Algorithm: id-X25519

   *  id-MLKEM768-ECDH-P256-HMAC-SHA256

      -  OID: 2.16.840.1.114027.80.5.2.54

      -  Label: "QSF-MLKEM768-P256-HMACSHA256"

      -  Key Derivation Function (KDF): HMAC-SHA256

      -  ML-KEM variant: ML-KEM-768

      -  Traditional Algorithm: ECDH

         o  Traditional KEM Algorithm: id-ecDH

         o  ECDH curve: secp256r1

   *  id-MLKEM768-ECDH-P384-HMAC-SHA256

      -  OID: 2.16.840.1.114027.80.5.2.55

      -  Label: "QSF-MLKEM768-P384-HMACSHA256"

      -  Key Derivation Function (KDF): HMAC-SHA256

      -  ML-KEM variant: ML-KEM-768

      -  Traditional Algorithm: ECDH

         o  Traditional KEM Algorithm: id-ecDH

         o  ECDH curve: secp384r1

   *  id-MLKEM768-ECDH-brainpoolP256r1-HMAC-SHA256

      -  OID: 2.16.840.1.114027.80.5.2.56

      -  Label: "QSF-MLKEM768-BP256-HMACSHA256"

      -  Key Derivation Function (KDF): HMAC-SHA256

      -  ML-KEM variant: ML-KEM-768

      -  Traditional Algorithm: ECDH

         o  Traditional KEM Algorithm: id-ecDH

         o  ECDH curve: brainpoolP256r1

   *  id-MLKEM1024-RSA3072-HMAC-SHA512

      -  OID: 2.16.840.1.114027.80.5.2.61

      -  Label: "QSF-MLKEM1024-RSAOAEP3072-HMACSHA512"

      -  Key Derivation Function (KDF): HMAC-SHA512

      -  ML-KEM variant: ML-KEM-1024

      -  Traditional Algorithm: RSA

         o  Traditional KEM Algorithm: id-RSAES-OAEP

         o  RSA size: 3072

         o  RSAES-OAEP parameters: See Table 2

   *  id-MLKEM1024-ECDH-P384-HMAC-SHA512

      -  OID: 2.16.840.1.114027.80.5.2.57

      -  Label: "QSF-MLKEM1024-P384-HMACSHA512"

      -  Key Derivation Function (KDF): HMAC-SHA512

      -  ML-KEM variant: ML-KEM-1024

      -  Traditional Algorithm: ECDH

         o  Traditional KEM Algorithm: id-ecDH

         o  ECDH curve: secp384r1

   *  id-MLKEM1024-ECDH-brainpoolP384r1-HMAC-SHA512

      -  OID: 2.16.840.1.114027.80.5.2.58

      -  Label: "QSF-MLKEM1024-BP384-HMACSHA512"

      -  Key Derivation Function (KDF): HMAC-SHA512

      -  ML-KEM variant: ML-KEM-1024

      -  Traditional Algorithm: ECDH

         o  Traditional KEM Algorithm: id-ecDH

         o  ECDH curve: brainpoolP384r1

   *  id-MLKEM1024-X448-SHA3-256

      -  OID: 2.16.840.1.114027.80.5.2.59

      -  Label: "QSF-MLKEM1024-X448-SHA3256"

      -  Key Derivation Function (KDF): SHA3-256

      -  ML-KEM variant: ML-KEM-1024

      -  Traditional Algorithm: X448

         o  Traditional KEM Algorithm: id-X448

   *  id-MLKEM1024-ECDH-P521-HMAC-SHA512

      -  OID: 2.16.840.1.114027.80.5.2.60

      -  Label: "QSF-MLKEM1024-P521-HMACSHA512"

      -  Key Derivation Function (KDF): HMAC-SHA512

      -  ML-KEM variant: ML-KEM-1024

      -  Traditional Algorithm: ECDH

         o  Traditional KEM Algorithm: id-ecDH

         o  ECDH curve: secp521r1

   In alignment with ML-KEM [FIPS.203], Composite KEM algorithms output
   a 256-bit shared secret key at all security levels, truncating is
   necessary as described in Section 4.4.

   For all RSA key types and sizes, the exponent is RECOMMENDED to be
   65537.  Implementations MAY support only 65537 and reject other
   exponent values.  Legacy RSA implementations that use other values
   for the exponent MAY be used to within a composite, but need to be
   careful when interoperating with other implementations.

   The KDFs were chosen to roughly match the security level of the
   stronger component.  In the case of X25519 and X448 SHA3-256 is used
   to match the construction in [X-Wing].

7.1.  RSA-OAEP Parameters

   Use of RSA-OAEP [RFC8017] requires additional parameters to be
   specified.

   The RSA component keys MUST be generated at the specified 2048-bit,
   3072-bit, 4096-bit key sizes respectively (up to small differences
   such as dropping leading zeros); intermediate sizes are not
   acceptable.

   As with the other Composite ML-KEM algorithms, AlgorithmIdentifier
   parameters MUST be absent.  The RSA-OAEP primitive SHALL be
   instantiated with the following hard-coded parameters which are the
   same for the 2048, 3072 and 4096 bit security levels since the
   objective is to carry and output a 256-bit shared secret key at all
   security levels.

             +=============================+=================+
             | RSAES-OAEP-params           | Value           |
             +=============================+=================+
             | hashAlgorithm               | id-sha256       |
             +-----------------------------+-----------------+
             | MaskGenAlgorithm.algorithm  | id-mgf1         |
             +-----------------------------+-----------------+
             | maskGenAlgorithm.parameters | id-sha256       |
             +-----------------------------+-----------------+
             | pSourceAlgorithm            | pSpecifiedEmpty |
             +-----------------------------+-----------------+
             | ss_len                      | 256 bits        |
             +-----------------------------+-----------------+

                        Table 2: RSA-OAEP Parameters

   Full specifications for the referenced algorithms can be found in
   Appendix B.

   Note: The mask length, according to [RFC8017], is k - hLen - 1, where
   k is the size of the RSA modulus.  Since the choice of hash function
   and the RSA key size is fixed for each composite algorithm,
   implementations could choose to pre-compute and hard-code the mask
   length.

7.2.  Rationale for choices

   In generating the list of composite algorithms, the idea was to
   provide composite algorithms at various security levels with varying
   performance characteristics.

   The main design consideration in choosing pairings is to prioritize
   providing pairings of each ML-KEM security level with commonly-
   deployed traditional algorithms.  This supports the design goal of
   using composites as a stepping stone to efficiently deploy post-
   quantum on top of existing hardened and certified traditional
   algorithm implementations.  This was prioritized rather than
   attempting to exactly match the security level of the post-quantum
   and traditional components -- which in general is difficult to do
   since there is no academic consensus on how to compare the "bits of
   security" against classical attackers and "qubits of security"
   against quantum attackers.

   SHA2 is prioritized over SHA3 in order to facilitate implementations
   that do not have easy access to SHA3 outside of the ML-KEM module.
   However SHA3 is used with X25519 and X448 to match the construction
   in [X-Wing].  This also provides a slight efficiency gain for the
   X25519 and X448 based composites since a single invocation of SHA3 is
   known to behave as a dual-PRF, and thus is sufficient for use as a
   KDF, see Section 10.2, compared with an HMAC-SHA2 construction.

   While it may seem odd to use 256-bit outputs at all security levels,
   this aligns with ML-KEM [FIPS.203] which produces a 256-bit shared
   secret key at all security levels.  All hash functions used have >=
   256 bits of (2nd) pre-image resistance, which is the required
   property for a KDF to provide 128 bits of security, as allowed in
   Table 3 of [SP.800-57pt1r5].  Composite algorithms at higher security
   levels use a larger hash function in order to preserve internal
   collision resistance of the hash function at a comparable strength to
   the underlying component algorithms up to the point where truncation
   to a 256-bit output is performed.

8.  ASN.1 Module

   <CODE STARTS>

   Composite-MLKEM-2025
         { iso(1) identified-organization(3) dod(6) internet(1)
           security(5) mechanisms(5) pkix(7) id-mod(0)
           id-mod-composite-mlkem-2025(TBDMOD) }

   DEFINITIONS IMPLICIT TAGS ::= BEGIN

   EXPORTS ALL;

   IMPORTS

   PUBLIC-KEY, AlgorithmIdentifier{}, SMIME-CAPS
     FROM AlgorithmInformation-2009  -- RFC 5912 [X509ASN1]
         { iso(1) identified-organization(3) dod(6) internet(1)
           security(5) mechanisms(5) pkix(7) id-mod(0)
           id-mod-algorithmInformation-02(58) }

   KEM-ALGORITHM
     FROM KEMAlgorithmInformation-2023
         { iso(1) identified-organization(3) dod(6) internet(1)
           security(5) mechanisms(5) pkix(7) id-mod(0)
           id-mod-kemAlgorithmInformation-2023(109) }
   ;


   --
   -- Object Identifiers
   --

   --
   -- Information Object Classes
   --

   pk-CompositeKEM {OBJECT IDENTIFIER:id}
     PUBLIC-KEY ::= {
       IDENTIFIER id
       -- KEY without ASN.1 wrapping --
       PARAMS ARE absent
       CERT-KEY-USAGE { keyEncipherment }
     }

   kema-CompositeKEM {
     OBJECT IDENTIFIER:id,
       PUBLIC-KEY:publicKeyType }
       KEM-ALGORITHM ::= {
            IDENTIFIER id
            -- VALUE without ASN.1 wrapping --
            PARAMS ARE absent
            PUBLIC-KEYS { publicKeyType }
            SMIME-CAPS { IDENTIFIED BY id }
           }



   --
   -- Composite KEM Algorithms
   --


   -- TODO: OID to be replaced by IANA
   id-MLKEM768-RSA2048-HMAC-SHA256 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 50 }

   pk-MLKEM768-RSA2048-HMAC-SHA256 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-RSA2048-HMAC-SHA256 }

   kema-MLKEM768-RSA2048-HMAC-SHA256 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-RSA2048-HMAC-SHA256,
         pk-MLKEM768-RSA2048-HMAC-SHA256 }



   -- TODO: OID to be replaced by IANA
   id-MLKEM768-RSA3072-HMAC-SHA256 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 51 }

   pk-MLKEM768-RSA3072-HMAC-SHA256 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-RSA3072-HMAC-SHA256 }

   kema-MLKEM768-RSA3072-HMAC-SHA256 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-RSA3072-HMAC-SHA256,
         pk-MLKEM768-RSA3072-HMAC-SHA256 }



   -- TODO: OID to be replaced by IANA
   id-MLKEM768-RSA4096-HMAC-SHA256 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 52 }

   pk-MLKEM768-RSA4096-HMAC-SHA256 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-RSA4096-HMAC-SHA256 }

   kema-MLKEM768-RSA4096-HMAC-SHA256 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-RSA4096-HMAC-SHA256,
         pk-MLKEM768-RSA4096-HMAC-SHA256 }



   -- TODO: OID to be replaced by IANA
   id-MLKEM768-X25519-SHA3-256 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 53 }

   pk-MLKEM768-X25519-SHA3-256 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-X25519-SHA3-256 }

   kema-MLKEM768-X25519-SHA3-256 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-X25519-SHA3-256,
         pk-MLKEM768-X25519-SHA3-256 }


   -- TODO: OID to be replaced by IANA
   id-MLKEM768-ECDH-P256-HMAC-SHA256 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 54 }

   pk-MLKEM768-ECDH-P256-HMAC-SHA256 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-ECDH-P256-HMAC-SHA256 }

   kema-MLKEM768-ECDH-P256-HMAC-SHA256 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-ECDH-P256-HMAC-SHA256,
         pk-MLKEM768-ECDH-P256-HMAC-SHA256 }



   -- TODO: OID to be replaced by IANA
   id-MLKEM768-ECDH-P384-HMAC-SHA256 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 55 }

   pk-MLKEM768-ECDH-P384-HMAC-SHA256 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-ECDH-P384-HMAC-SHA256 }

   kema-MLKEM768-ECDH-P384-HMAC-SHA256 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-ECDH-P384-HMAC-SHA256,
         pk-MLKEM768-ECDH-P384-HMAC-SHA256 }



   -- TODO: OID to be replaced by IANA
   id-MLKEM768-ECDH-brainpoolP256r1-HMAC-SHA256 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 56 }

   pk-MLKEM768-ECDH-brainpoolP256r1-HMAC-SHA256 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM768-ECDH-brainpoolP256r1-HMAC-SHA256 }

   kema-MLKEM768-ECDH-brainpoolP256r1-HMAC-SHA256 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM768-ECDH-brainpoolP256r1-HMAC-SHA256,
         pk-MLKEM768-ECDH-brainpoolP256r1-HMAC-SHA256 }


   -- TODO: OID to be replaced by IANA
   id-MLKEM1024-RSA3072-HMAC-SHA512 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 61 }

   pk-MLKEM1024-RSA3072-HMAC-SHA512 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM1024-RSA3072-HMAC-SHA512 }

   kema-MLKEM1024-RSA3072-HMAC-SHA512 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM1024-RSA3072-HMAC-SHA512,
         pk-MLKEM1024-RSA3072-HMAC-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-MLKEM1024-ECDH-P384-HMAC-SHA512 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 57 }

   pk-MLKEM1024-ECDH-P384-HMAC-SHA512 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM1024-ECDH-P384-HMAC-SHA512 }

   kema-MLKEM1024-ECDH-P384-HMAC-SHA512 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM1024-ECDH-P384-HMAC-SHA512,
         pk-MLKEM1024-ECDH-P384-HMAC-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-MLKEM1024-ECDH-brainpoolP384r1-HMAC-SHA512 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 58 }

   pk-MLKEM1024-ECDH-brainpoolP384r1-HMAC-SHA512 PUBLIC-KEY ::=
     pk-CompositeKEM{
       id-MLKEM1024-ECDH-brainpoolP384r1-HMAC-SHA512 }

   kema-MLKEM1024-ECDH-brainpoolP384r1-HMAC-SHA512 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM1024-ECDH-brainpoolP384r1-HMAC-SHA512,
         pk-MLKEM1024-ECDH-brainpoolP384r1-HMAC-SHA512 }


   -- TODO: OID to be replaced by IANA
   id-MLKEM1024-X448-SHA3-256 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 59 }

   pk-MLKEM1024-X448-SHA3-256 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM1024-X448-SHA3-256 }

   kema-MLKEM1024-X448 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM1024-X448-SHA3-256,
         pk-MLKEM1024-X448-SHA3-256 }


   -- TODO: OID to be replaced by IANA
   id-MLKEM1024-ECDH-P521-HMAC-SHA512 OBJECT IDENTIFIER ::= {
     joint-iso-itu-t(2) country(16) us(840) organization(1)
     entrust(114027) algorithm(80) explicitcomposite(5) kem(2) 60 }

   pk-MLKEM1024-ECDH-P521-HMAC-SHA512 PUBLIC-KEY ::=
     pk-CompositeKEM {
       id-MLKEM1024-ECDH-P521-HMAC-SHA512 }

   kema-MLKEM1024-ECDH-P521-HMAC-SHA512 KEM-ALGORITHM ::=
       kema-CompositeKEM{
         id-MLKEM1024-ECDH-P521-HMAC-SHA512,
         pk-MLKEM1024-ECDH-P521-HMAC-SHA512 }

   END

   <CODE ENDS>

9.  IANA Considerations

9.1.  Object Identifier Allocations

   EDNOTE to IANA: OIDs will need to be replaced in both the ASN.1
   module and in Section 7.

9.1.1.  Module Registration

   The following is to be registered in "SMI Security for PKIX Module
   Identifier":

   *  Decimal: IANA Assigned - *Replace TBDMOD*

   *  Description: Composite-KEM-2023 - id-mod-composite-kems

   *  References: This Document

9.1.2.  Object Identifier Registrations

   The following is to be registered in "SMI Security for PKIX
   Algorithms":

   *  id-MLKEM768-RSA2048-HMAC-SHA256

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-RSA2048-HMAC-SHA256

      -  References: This Document

   *  id-MLKEM768-RSA3072-HMAC-SHA256

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-RSA3072-HMAC-SHA256

      -  References: This Document

   *  id-MLKEM768-RSA4096-HMAC-SHA256

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-RSA4096-HMAC-SHA256

      -  References: This Document

   *  id-MLKEM768-ECDH-P256-HMAC-SHA256

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-ECDH-P256-HMAC-SHA256

      -  References: This Document

   *  id-MLKEM768-ECDH-P384-HMAC-SHA256

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-ECDH-P384-HMAC-SHA256

      -  References: This Document

   *  id-MLKEM768-ECDH-brainpoolP256r1-HMAC-SHA256

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-ECDH-brainpoolP256r1-HMAC-SHA256

      -  References: This Document

   *  id-MLKEM768-X25519-SHA3-256

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM768-X25519-SHA3-256

      -  References: This Document

   *  id-MLKEM1024-RSA3072-HMAC-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM1024-RSA3072-HMAC-SHA512

      -  References: This Document

   *  id-MLKEM1024-ECDH-P384-HMAC-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM1024-ECDH-P384-HMAC-SHA512

      -  References: This Document

   *  id-MLKEM1024-ECDH-brainpoolP384r1-HMAC-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM1024-ECDH-brainpoolP384r1-HMAC-SHA512

      -  References: This Document

   *  id-MLKEM1024-X448-SHA3-256

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM1024-X448-SHA3-256

      -  References: This Document

   *  id-MLKEM1024-ECDH-P521-HMAC-SHA512

      -  Decimal: IANA Assigned

      -  Description: id-MLKEM1024-ECDH-P521-HMAC-SHA512

      -  References: This Document

10.  Security Considerations

10.1.  Why Hybrids?

   In broad terms, a PQ/T Hybrid can be used either to provide dual-
   algorithm security or to provide migration flexibility.  Let's
   quickly explore both.

   Dual-algorithm security.  The general idea is that the data is
   protected by two algorithms such that an attacker would need to break
   both in order to compromise the data.  As with most of cryptography,
   this property is easy to state in general terms, but becomes more
   complicated when expressed in formalisms.  The following sections go
   into more detail here.

   Migration flexibility.  Some PQ/T hybrids exist to provide a sort of
   "OR" mode where the application can choose to use one algorithm or
   the other or both.  The intention is that the PQ/T hybrid mechanism
   builds in backwards compatibility to allow legacy and upgraded
   applications to co-exist and communicate.  The composite algorithms
   presented in this specification do not provide this since they
   operate in a strict "AND" mode.  They do, however, provide codebase
   migration flexibility.  Consider that an organization has today a
   mature, validated, certified, hardened implementation of RSA or ECC;
   composites allow them to add an ML-KEM implementation which
   immediately starts providing benefits against harvest-now-decrypt-
   later attacks even if that ML-KEM implementation is still an
   experimental, non-validated, non-certified, non-hardened
   implementation.  More details of obtaining FIPS certification of a
   composite algorithm can be found in Section 11.1.

10.2.  KEM Combiner

   The KEM combiner from Section 4.4 is reproduced here for reference.

     KDF(mlkemSS || tradSS || tradCT || tradPK || Label)

                    Figure 3: KEM combiner construction

   The primary security property of the KEM combiner is that it
   preserves IND-CCA2 of the overall Composite ML-KEM so long as at
   least one component is IND-CCA2 [X-Wing] [GHP18].  Additionally, we
   also need to consider the case where one of the component algorithms
   is completely broken; that the private key is known to an attacker,
   or worse that the public key, private key, and ciphertext are
   manipulated by the attacker.  In this case, we rely on the
   construction of the KEM combiner to ensure that the value of the
   other shared secret key cannot be leaked or the combined shared
   secret key predicted via manipulation of the broken algorithm.

   Each registered Composite ML-KEM algorithm specifies the choice of
   KDF and Label -- see Section 7.  Given that each Composite ML-KEM
   algorithm fully specifies the component algorithms, including for
   example the size of the RSA modulus, all inputs to the KEM combiner
   are fixed-size and thus do not require length-prefixing.

   *  mlkemSS is always 32 bytes.

   *  tradSS in the case of DH this is derived by the decapsulator and
      therefore the length is not controlled by the attacker, however in
      the case of RSA-OAEP this value is directly chosen by the sender
      and both the length and content could be freely chosen by an
      attacker.

   *  tradCT is either an elliptic curve public key or an RSA-OAEP
      ciphertext which is required to have its length checked by step 1b
      of RSAES-OAEP-DECRYPT in [RFC8017].

   *  tradPK is the public key of the traditional component (elliptic
      curve or RSA) and therefore fixed-length.

   *  Label is a fixed value specified in this document.

10.2.1.  IND-CCA Security of the hybrid scheme

   Informally, a Composite ML-KEM algorithm is secure if the combiner
   (HMAC-SHA2 or SHA3) is secure, and either ML-KEM is secure or the
   traditional component (RSA-OAEP, ECDH, X25519 or X448) is secure.

   The security of ML-KEM and DH hybrids is covered in [X-Wing] and
   requires that the first KEM component (ML-KEM in this construction)
   is IND-CCA and second ciphertext preimage resistant (C2PRI) and that
   the second traditional component is IND-CCA.  This design choice
   improves performance by not including the large ML-KEM public key and
   ciphertext, but means that an implementation error in the ML-KEM
   component that affects the ciphertext check step of the FO transform
   could result in the overall composite no longer achieving IND-CCA2
   security.  Note that ciphertext collisions exist in the traditional
   component by the composite design choice to support any underlying
   encoding of the traditional component, such as compressed vs
   uncompressed EC points as the DH KEM ciphertext.  This solution
   remains IND-CCA due to binding the tradPK and tradCT in the KEM
   combiner.

   The QSF framework presented in [X-Wing] is extended to cover RSA-OAEP
   as the traditional algorithm in place of DH by noting that RSA-OAEP
   is also IND-CCA secure [RFC8017].

   Note that X-Wing uses SHA3 as the combiner KDF whereas Composite ML-
   KEM uses either SHA3 or HMAC-SHA2 which are interchangeable in the
   X-Wing proof since both behave as random oracles under multiple
   concatenated inputs.

   The composite combiner cannot be assumed to be secure when used with
   different KEMs and a more cautious approach would bind the public key
   and ciphertext of the first KEM as well.

10.2.2.  Second pre-image resistance of component KEMs

   The notion of a "ciphertext second pre-image resistant KEM" is
   defined in [X-Wing] as being the property that it is computationally
   difficult to find two different ciphertexts c != c' that will
   decapsulate to the same shared secret key under the same public key.
   For the purposes of a hybrid KEM combiner, this property means that
   given two composite ciphertexts (c1, c2) and (c1', c2'), we must
   obtain a unique overall shared secret key so long as either c1 != c1'
   or c2 != c2' -- i.e. the overall Composite ML-KEM is ciphertext
   second pre-image resistant, and therefore secure so long as one of
   the component KEMs is secure.

   In [X-Wing] it is proven that ML-KEM is a second pre-image resistant
   KEM and therefore the ML-KEM ciphertext can safely be omitted from
   the KEM combiner.  Note that this makes a fundamental assumption on
   ML-KEM remaining ciphertext second pre-image resistant, and therefore
   this formulation of KEM combiner does not fully protect against
   implementation errors in the ML-KEM component -- particularly around
   the ciphertext check step of the Fujisaki-Okamoto transform -- which
   could trivially lead to second ciphertext pre-image attacks that
   break the IND-CCA2 security of the ML-KEM component and of the
   overall Composite ML-KEM.  This could be more fully mitigated by
   binding the ML-KEM ciphertext in the combiner, but a design decision
   was made to settle for protection against algorithmic attacks and not
   implementation attacks against ML-KEM in order to increase
   performance.

   However, since neither RSA-OAEP nor DH guarantee second pre-image
   resistance at all, even in a correct implementation, these
   ciphertexts are bound to the key derivation in order to guarantee
   that c != c' will yield a unique ciphertext, and thus restoring
   second pre-image resistance to the overall Composite ML-KEM.

10.2.3.  SHA3 vs HMAC-SHA2

   In order to achieve the desired security property that the Composite
   ML-KEM is IND-CCA2 whenever at least one of the component KEMs is,
   the KDF used in the KEM combiner needs to possess collision and
   second pre-image resistance with respect to each of its inputs
   independently; a property sometimes called "dual-PRF" [Aviram22].
   Collision and second-pre-image resistance protects against compromise
   of one component algorithm from resulting in the ability to construct
   multiple different ciphertexts which result in the same shared secret
   key.  Pre-image resistance protects against compromise of one
   component algorithm being used to attack and learn the value of the
   other shared secret key.

   SHA3 is known to have all of the necessary dual-PRF properties
   [X-Wing], but SHA2 does not and therefore all SHA2-based
   constructions MUST use SHA2 within an HMAC construction such as HKDF-
   Extract upon which the composite HMAC combiner is based [GHP18].

10.2.4.  Generifying this construction

   It should be clear that the security analysis of the presented KEM
   combiner construction relies heavily on the specific choices of
   component algorithms and combiner KDF, and this combiner construction
   SHOULD NOT by applied to any other combination of ciphers without
   performing the appropriate security analysis.

10.3.  Key Reuse

   While conformance with this specification requires that both
   components of a composite key MUST be freshly generated, the
   designers are aware that some implementers may be forced to break
   this rule due to operational constraints.  This section documents the
   implications of doing so.

   When using single-algorithm cryptography, the best practice is to
   always generate fresh keying material for each purpose, for example
   when renewing a certificate, or obtaining both a TLS and S/MIME
   certificate for the same device.  However, in practice key reuse in
   such scenarios is not always catastrophic to security and therefore
   often tolerated.  However this reasoning does not hold in the PQ/T
   hybrid setting.

   Within the broader context of PQ/T hybrids, we need to consider new
   attack surfaces that arise due to the hybrid constructions and did
   not exist in single-algorithm contexts.  One of these is key reuse
   where the component keys within a hybrid are also used by themselves
   within a single-algorithm context.  For example, it might be tempting
   for an operator to take already-deployed RSA keys and add an ML-KEM
   key to them to form a hybrid.  Within a hybrid signature context this
   leads to a class of attacks referred to as "stripping attacks" where
   one component signature can be extracted and presented as a single-
   algorithm signature.  Hybrid KEMs using a concatenation-style KEM
   combiner, as is done in this specification, do not have the analogous
   attack surface because even if an attacker is able to extract and
   decrypt one of the component ciphertexts, this will yield a different
   shared secret key than the overall shared secret key derived from the
   composite, so any subsequent symmetric cryptographic operations will
   fail.

   In addition, there is a further implication to key reuse regarding
   certificate revocation.  Upon receiving a new certificate enrolment
   request, many certification authorities will check if the requested
   public key has been previously revoked due to key compromise.  Often
   a CA will perform this check by using the public key hash.
   Therefore, if one, or even both, components of a composite have been
   previously revoked, the CA may only check the hash of the combined
   composite key and not find the revocations.  Therefore, because the
   possibility of key reuse exists even though forbidden in this
   specification, CAs performing revocation checks on a composite key
   SHOULD also check both component keys independently to verify that
   the component keys have not been revoked.

10.4.  Decapsulation failure

   Provided all inputs are well-formed, the key establishment procedure
   of ML-KEM will never explicitly fail.  Specifically, the ML-
   KEM.Encaps() and ML-KEM.Decaps() algorithms from [FIPS.203] will
   always output a value with the same data type as a shared secret key,
   and will never output an error or failure symbol.  However, it is
   possible (though extremely unlikely) that the process will fail in
   the sense that ML-KEM.Encaps() and ML-KEM.Decaps() will produce
   different outputs, even though both of them are behaving honestly and
   no adversarial interference is present.  This is due to the lattice
   arithmetic for decapsulation with the secret key having hit an
   unrecoverable degenerate case that could not have been predicted by
   the encapsulator without knowledge of the secret key.  In this case,
   the sender and recipient clearly did not succeed in producing a
   shared secret key.  This event is called a decapsulation failure.
   Estimates for the decapsulation failure probability (or rate) for
   each of the ML-KEM parameter sets are provided in Table 1 of
   [FIPS.203] and reproduced here in Table 3.

              +===============+============================+
              | Parameter set | Decapsulation failure rate |
              +===============+============================+
              | ML-KEM-512    | 2^(-139)                   |
              +---------------+----------------------------+
              | ML-KEM-768    | 2^(-164)                   |
              +---------------+----------------------------+
              | ML-KEM-1024   | 2^(-174)                   |
              +---------------+----------------------------+

               Table 3: ML-KEM decapsulation failure rates

   In the case of ML-KEM decapsulation failure, Composite ML-KEM MUST
   preserve the same behavior and return a well-formed output shared
   secret key.

10.5.  Policy for Deprecated and Acceptable Algorithms

   Traditionally, a public key or certificate contains a single
   cryptographic algorithm.  If and when an algorithm becomes deprecated
   (for example, RSA-512, or SHA1), the path to deprecating it through
   policy and removing it from operational environments is, at least is
   principle, straightforward.

   In the composite model this is less obvious since a PQ/T hybrid is
   expected to still be considered valid after the traditional component
   is deprecated for individual use.  As such, a single composite public
   key or certificate may contain a mixture of deprecated and non-
   deprecated algorithms.  In general this should be manageable through
   policy by removing OIDs for the standalone component algorithms while
   still allowing OIDs for composite algorithms.  However, complications
   may arise when the composite implementation needs to invoke the
   cryptographic module for a deprecated component algorithm.  In
   particular, this could lead to complex Cryptographic Bills of
   Materials that show implementations of deprecated algorithms still
   present and being used.

11.  Implementation Considerations

11.1.  FIPS Certification

   The following sections give guidance to implementers wishing to FIPS-
   certify a composite implementation.

   This guidance is not authoritative and has not been endorsed by NIST.

   Implementers seeking FIPS certification of a composite KEM algorithm
   where only one of the component algorithms has been FIPS-validated or
   FIPS-approved should credit the FIPS-validated component algorithm
   with full security strength, the non-FIPS-validated component
   algorithm with zero security, and the overall composite should be
   considered at least as strong and thus FIPS-approved.

   The composite algorithm has been designed to treat the underlying
   primitives as "black-box implementations" and not impose any
   additional requirements on them that could require an existing
   implementation of an underlying primitive to run in a mode different
   from the one under which it was certified.  For example, the KeyGen
   defined in Section 4.1 invokes ML-KEM.KeyGen(seed) which might not be
   available in a cryptographic module running in FIPS-mode, but
   Section 4.1 is only a suggested implementation and the composite
   KeyGen MAY be implemented using a different available interface for
   ML-KEM.KeyGen.

   The authors wish to note that composite algorithms provide a design
   pattern to provide utility in future situations that require care to
   remain FIPS-compliant, such as future cryptographic migrations as
   well as bridging across jurisdictions with non-intersecting
   cryptographic requirements.

   The following sections go into further detail on specific issues that
   relate to FIPS certification.

11.1.1.  Combiner Function

   For reference, the KEM combiner used in Composite ML-KEM is:

   ss = KDF(mlkemSS || tradSS || tradCT || tradPK || Label)

   where KDF is either SHA3 or HMAC-SHA2.

   NIST SP 800-227 [SP-800-227ipd], which at the time of writing is in
   its initial public draft period, allows hybrid key combiners of the
   following form:

   K ← KDM(S1‖S2‖ · · · ‖St , OtherInput)           (14)

   Composite ML-KEM maps cleanly into this since it places the two
   shared secret keys mlkemSS || tradSS at the beginning of the KDF
   input such that all other inputs tradCT || tradPK || Label can be
   considered part of OtherInput for the purposes of FIPS certification.

   For the detailed steps of the Key Derivation Mechanism KDM,
   [SP-800-227ipd] refers to [SP.800-56Cr2].

   Compliance of the Composite ML-KEM variants is achieved in the
   following way:

   The Composite ML-KEM algorithms using HMAC-SHA2 can be certified
   under [SP.800-56Cr2] One-Step Key Derivation Option 2: H(x) = HMAC-
   hash(salt, x) where salt is the empty (0 octet) string, which will
   internally be mapped to the zero vector 0x00..00 of the correct input
   size for the underlying hash function.  This satisfies the
   requirement in [SP.800-56Cr2]:

      "in the absence of an agreed-upon alternative – the default_salt
      shall be an all-zero byte string whose bit length equals that
      specified as the bit length of an input block for the hash
      function, hash"

   The Composite ML-KEM algorithms using SHA3 can be certified under
   [SP.800-56Cr2] One-Step Key Derivation Option 1: H(x) = hash(x).

   [SP.800-56Cr2] section 4 "One-Step Key Derivation" requires a counter
   which begins at the 4-byte value 0x00000001.  However, the counter is
   allowed to be omitted when the hash function is executed only once,
   as specified on page 159 of the FIPS 140-3 Implementation Guidance
   [FIPS-140-3-IG].

11.1.2.  Order of KDF inputs with Non-Approved Algorithms

   [SP-800-227ipd] adds an important stipulation that was not present in
   earlier NIST specifications:

      This publication approves the use of the key combiner (14) for any
      t > 1, so long as at least one shared secret (i.e., S_j for some
      j) is a shared secret generated from the key- establishment
      methods of SP 800-56A or SP 800-56B, or an approved KEM.

   This means that although Composite ML-KEM always places the shared
   secret key from ML-KEM in the first slot, a Composite ML-KEM can be
   FIPS certified so long as either component is FIPS certified.  This
   is important for several reasons.  First, in the early stages of PQC
   migration, composites allow for a non-FIPS certified ML-KEM
   implementation to be added to a module that already has a FIPS
   certified traditional component, and the resulting composite can be
   FIPS certified.  Second, when eventually RSA and Elliptic Curve are
   no longer FIPS-allowed, the composite can retain its FIPS certified
   status on the strength of the ML-KEM component.  Third, while this is
   outside the scope of this specification, the general composite
   construction could be used to create FIPS certified algorithms that
   contain a component algorithm from a different jurisdiction.  Third,
   a composite where both components are FIPS-certified could allow an
   implementer to patch one component algorithm while awaiting re-
   certification while continuing to use the overall composite in FIPS
   mode.

   At the time of writing, [SP-800-227ipd] is in its public draft period
   and not yet in force.  A Composite ML-KEM implementation using a
   FIPS-certified traditional component and a non-FIPS certified ML-KEM
   is not believed to be certifiable under [SP.800-56Cr2] since this
   requires the shared secret key from the certified algorithm to be in
   the first slot.

11.2.  Backwards Compatibility

   The term "backwards compatibility" is used here to mean that existing
   systems as they are deployed today can interoperate with the upgraded
   systems of the future.  This draft explicitly does not provide
   backwards compatibility, only upgraded systems will understand the
   OIDs defined in this specification.

   These migration and interoperability concerns need to be thought
   about in the context of various types of protocols that make use of
   X.509 and PKIX with relation to key establishment and content
   encryption, from online negotiated protocols such as TLS 1.3
   [RFC8446] and IKEv2 [RFC7296], to non-negotiated asynchronous
   protocols such as S/MIME signed email [RFC8551], as well as myriad
   other standardized and proprietary protocols and applications that
   leverage CMS [RFC5652] encrypted structures.

11.3.  Profiling down the number of options

   One daunting aspect of this specification is the number of composite
   algorithm combinations.  Each option has been specified because there
   is a community that has a direct application for it; typically
   because the traditional component is already deployed in a change-
   managed environment, or because that specific traditional component
   is required for regulatory reasons.

   However, this large number of combinations leads either to fracturing
   of the ecosystem into non-interoperable sub-groups when different
   communities choose non-overlapping subsets to support, or on the
   other hand it leads to spreading development resources too thin when
   trying to support all options.

   This specification does not list any particular composite algorithm
   as mandatory-to-implement, however organizations that operate within
   specific application domains are encouraged to define profiles that
   select a small number of composites appropriate for that application
   domain.  For applications that do not have any regulatory
   requirements or legacy implementations to consider, it is RECOMMENDED
   to focus implementation effort on:

   id-MLKEM768-X25519-SHA3-256  (aka "X-Wing")
   id-MLKEM768-ECDH-P256-HMAC-SHA256

   In applications that only allow NIST PQC Level 5, it is RECOMMENDED
   to focus implementation effort on:

   id-MLKEM1024-ECDH-P384-HMAC-SHA512

11.4.  Decapsulation Requires the Public Key

   ML-KEM always requires the public key in order to perform various
   steps of the Fujisaki-Okamoto decapsulation [FIPS.203], and for this
   reason the private key encoding specified in FIPS 203 includes the
   public key.

   Moreover, the KEM combiner as specified in Section 4.4 requires the
   public key of the traditional component in order to achieve the
   public-key binding property and ciphertext collision resistance as
   described in Section 10.2.  For this reason, the private key
   serialization defined in Section 5.2 carries the traditional public
   key so that it is easily available to the decapsulater.

   Implementers who choose to use a different private key encoding than
   the one specified in this document MUST consider how to provide the
   component public keys to the decapsulate routine.  This includes, for
   example, implementations that use a hardware security module to hold
   the private key.  While some implementations might contain routines
   to computationally derive the public key from the private key, it is
   not guaranteed that all implementations will support this.  In some
   implementations, the application might be required to cache the
   public key or certificate associated with the private key so that the
   public key can be retrieved for the purposes of decapsulation.

12.  References

12.1.  Normative References

   [FIPS.202] National Institute of Standards and Technology (NIST),
              "SHA-3 Standard: Permutation-Based Hash and Extendable-
              Output Functions", August 2015,
              <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.202.pdf>.

   [FIPS.203] National Institute of Standards and Technology (NIST),
              "Module-Lattice-based Key-Encapsulation Mechanism
              Standard", August 2024,
              <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.203.pdf>.

   [FIPS.204] National Institute of Standards and Technology (NIST),
              "Module-Lattice-Based Digital Signature Standard", August
              2024, <https://nvlpubs.nist.gov/nistpubs/FIPS/
              NIST.FIPS.204.pdf>.

   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-
              Hashing for Message Authentication", RFC 2104,
              DOI 10.17487/RFC2104, February 1997,
              <https://www.rfc-editor.org/info/rfc2104>.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/info/rfc2119>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <https://www.rfc-editor.org/info/rfc5280>.

   [RFC5480]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,
              "Elliptic Curve Cryptography Subject Public Key
              Information", RFC 5480, DOI 10.17487/RFC5480, March 2009,
              <https://www.rfc-editor.org/info/rfc5480>.

   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, DOI 10.17487/RFC5652, September 2009,
              <https://www.rfc-editor.org/info/rfc5652>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <https://www.rfc-editor.org/info/rfc5869>.

   [RFC5915]  Turner, S. and D. Brown, "Elliptic Curve Private Key
              Structure", RFC 5915, DOI 10.17487/RFC5915, June 2010,
              <https://www.rfc-editor.org/info/rfc5915>.

   [RFC5958]  Turner, S., "Asymmetric Key Packages", RFC 5958,
              DOI 10.17487/RFC5958, August 2010,
              <https://www.rfc-editor.org/info/rfc5958>.

   [RFC6234]  Eastlake 3rd, D. and T. Hansen, "US Secure Hash Algorithms
              (SHA and SHA-based HMAC and HKDF)", RFC 6234,
              DOI 10.17487/RFC6234, May 2011,
              <https://www.rfc-editor.org/info/rfc6234>.

   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves
              for Security", RFC 7748, DOI 10.17487/RFC7748, January
              2016, <https://www.rfc-editor.org/info/rfc7748>.

   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,
              "PKCS #1: RSA Cryptography Specifications Version 2.2",
              RFC 8017, DOI 10.17487/RFC8017, November 2016,
              <https://www.rfc-editor.org/info/rfc8017>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

   [RFC8410]  Josefsson, S. and J. Schaad, "Algorithm Identifiers for
              Ed25519, Ed448, X25519, and X448 for Use in the Internet
              X.509 Public Key Infrastructure", RFC 8410,
              DOI 10.17487/RFC8410, August 2018,
              <https://www.rfc-editor.org/info/rfc8410>.

   [RFC8411]  Schaad, J. and R. Andrews, "IANA Registration for the
              Cryptographic Algorithm Object Identifier Range",
              RFC 8411, DOI 10.17487/RFC8411, August 2018,
              <https://www.rfc-editor.org/info/rfc8411>.

   [RFC9629]  Housley, R., Gray, J., and T. Okubo, "Using Key
              Encapsulation Mechanism (KEM) Algorithms in the
              Cryptographic Message Syntax (CMS)", RFC 9629,
              DOI 10.17487/RFC9629, August 2024,
              <https://www.rfc-editor.org/info/rfc9629>.

   [SEC1]     Certicom Research, "SEC 1: Elliptic Curve Cryptography",
              May 2009, <https://www.secg.org/sec1-v2.pdf>.

   [SEC2]     Certicom Research, "SEC 2: Recommended Elliptic Curve
              Domain Parameters", January 2010,
              <https://www.secg.org/sec2-v2.pdf>.

   [SP.800-185]
              National Institute of Standards and Technology (NIST),
              "SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash, and
              ParallelHash", December 2016,
              <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/
              NIST.SP.800-185.pdf>.

   [SP.800-56Ar3]
              National Institute of Standards and Technology (NIST),
              "Recommendation for Pair-Wise Key-Establishment Schemes
              Using Discrete Logarithm Cryptography", April 2018,
              <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/
              NIST.SP.800-56Ar3.pdf>.

   [SP.800-56Cr2]
              National Institute of Standards and Technology (NIST),
              "Recommendation for Key-Derivation Methods in Key-
              Establishment Schemes", August 2020,
              <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/
              NIST.SP.800-56Cr2.pdf>.

   [SP.800-57pt1r5]
              National Institute of Standards and Technology (NIST),
              "Recommendation for Key Management: Part 1 – General", May
              2020,
              <https://nvlpubs.nist.gov/nistpubs/SpecialPublications/
              NIST.SP.800-57pt1r5.pdf>.

   [X.690]    ITU-T, "Information technology - ASN.1 encoding Rules:
              Specification of Basic Encoding Rules (BER), Canonical
              Encoding Rules (CER) and Distinguished Encoding Rules
              (DER)", ISO/IEC 8825-1:2015, November 2015.

12.2.  Informative References

   [ANSSI2024]
              French Cybersecurity Agency (ANSSI), Federal Office for
              Information Security (BSI), Netherlands National
              Communications Security Agency (NLNCSA), and Swedish
              National Communications Security Authority, Swedish Armed
              Forces, "Position Paper on Quantum Key Distribution",
              n.d., <https://cyber.gouv.fr/sites/default/files/document/
              Quantum_Key_Distribution_Position_Paper.pdf>.

   [Aviram22] Aviram, N., Dowling, B., Komargodski, I., Paterson, K. G.,
              Ronen, E., and E. Yogev, "Practical (Post-Quantum) Key
              Combiners from One-Wayness and Applications to TLS", n.d.,
              <https://eprint.iacr.org/2022/065>.

   [Bindel2017]
              Bindel, N., Herath, U., McKague, M., and D. Stebila,
              "Transitioning to a quantum-resistant public key
              infrastructure", 2017, <https://link.springer.com/
              chapter/10.1007/978-3-319-59879-6_22>.

   [BSI2021]  Federal Office for Information Security (BSI), "Quantum-
              safe cryptography - fundamentals, current developments and
              recommendations", October 2021,
              <https://www.bsi.bund.de/SharedDocs/Downloads/EN/BSI/
              Publications/Brochure/quantum-safe-cryptography.pdf>.

   [ETSI.TS.103.744]
              ETSI, "ETSI TS 103 744 V1.2.1 CYBER-QSC; Quantum-safe
              Hybrid Key Establishment", March 2025,
              <https://www.etsi.org/deliver/
              etsi_ts/103700_103799/103744/01.02.01_60/
              ts_103744v010201p.pdf>.

   [FIPS-140-3-IG]
              National Institute of Standards and Technology (NIST),
              "Implementation Guidance for FIPS 140-3 and the
              Cryptographic Module Validation Program", July 2024,
              <https://csrc.nist.gov/csrc/media/Projects/cryptographic-
              module-validation-program/documents/fips%20140-3/
              FIPS%20140-3%20IG.pdf>.

   [GHP18]    Giacon, F., Heuer, F., and B. Poettering, "KEM Combiners",
              2018, <https://eprint.iacr.org/2018/024>.

   [I-D.ietf-lamps-kyber-certificates]
              Turner, S., Kampanakis, P., Massimo, J., and B.
              Westerbaan, "Internet X.509 Public Key Infrastructure -
              Algorithm Identifiers for the Module-Lattice-Based Key-
              Encapsulation Mechanism (ML-KEM)", Work in Progress,
              Internet-Draft, draft-ietf-lamps-kyber-certificates-10, 16
              April 2025, <https://datatracker.ietf.org/doc/html/draft-
              ietf-lamps-kyber-certificates-10>.

   [I-D.ietf-pquip-pqt-hybrid-terminology]
              D, F., P, M., and B. Hale, "Terminology for Post-Quantum
              Traditional Hybrid Schemes", Work in Progress, Internet-
              Draft, draft-ietf-pquip-pqt-hybrid-terminology-06, 10
              January 2025, <https://datatracker.ietf.org/doc/html/
              draft-ietf-pquip-pqt-hybrid-terminology-06>.

   [RFC2986]  Nystrom, M. and B. Kaliski, "PKCS #10: Certification
              Request Syntax Specification Version 1.7", RFC 2986,
              DOI 10.17487/RFC2986, November 2000,
              <https://www.rfc-editor.org/info/rfc2986>.

   [RFC4210]  Adams, C., Farrell, S., Kause, T., and T. Mononen,
              "Internet X.509 Public Key Infrastructure Certificate
              Management Protocol (CMP)", RFC 4210,
              DOI 10.17487/RFC4210, September 2005,
              <https://www.rfc-editor.org/info/rfc4210>.

   [RFC4211]  Schaad, J., "Internet X.509 Public Key Infrastructure
              Certificate Request Message Format (CRMF)", RFC 4211,
              DOI 10.17487/RFC4211, September 2005,
              <https://www.rfc-editor.org/info/rfc4211>.

   [RFC5639]  Lochter, M. and J. Merkle, "Elliptic Curve Cryptography
              (ECC) Brainpool Standard Curves and Curve Generation",
              RFC 5639, DOI 10.17487/RFC5639, March 2010,
              <https://www.rfc-editor.org/info/rfc5639>.

   [RFC5914]  Housley, R., Ashmore, S., and C. Wallace, "Trust Anchor
              Format", RFC 5914, DOI 10.17487/RFC5914, June 2010,
              <https://www.rfc-editor.org/info/rfc5914>.

   [RFC5990]  Randall, J., Kaliski, B., Brainard, J., and S. Turner,
              "Use of the RSA-KEM Key Transport Algorithm in the
              Cryptographic Message Syntax (CMS)", RFC 5990,
              DOI 10.17487/RFC5990, September 2010,
              <https://www.rfc-editor.org/info/rfc5990>.

   [RFC6090]  McGrew, D., Igoe, K., and M. Salter, "Fundamental Elliptic
              Curve Cryptography Algorithms", RFC 6090,
              DOI 10.17487/RFC6090, February 2011,
              <https://www.rfc-editor.org/info/rfc6090>.

   [RFC7292]  Moriarty, K., Ed., Nystrom, M., Parkinson, S., Rusch, A.,
              and M. Scott, "PKCS #12: Personal Information Exchange
              Syntax v1.1", RFC 7292, DOI 10.17487/RFC7292, July 2014,
              <https://www.rfc-editor.org/info/rfc7292>.

   [RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.
              Kivinen, "Internet Key Exchange Protocol Version 2
              (IKEv2)", STD 79, RFC 7296, DOI 10.17487/RFC7296, October
              2014, <https://www.rfc-editor.org/info/rfc7296>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/info/rfc8446>.

   [RFC8551]  Schaad, J., Ramsdell, B., and S. Turner, "Secure/
              Multipurpose Internet Mail Extensions (S/MIME) Version 4.0
              Message Specification", RFC 8551, DOI 10.17487/RFC8551,
              April 2019, <https://www.rfc-editor.org/info/rfc8551>.

   [RFC9180]  Barnes, R., Bhargavan, K., Lipp, B., and C. Wood, "Hybrid
              Public Key Encryption", RFC 9180, DOI 10.17487/RFC9180,
              February 2022, <https://www.rfc-editor.org/info/rfc9180>.

   [SP-800-227ipd]
              Alagic, G., Barker, E., Chen, L., Moody, D., Robinson, A.,
              Silberg, H., Waller, N., and National Institute of
              Standards and Technology (NIST), "Recommendations for Key-
              Encapsulation Mechanisms (Initial Public Draft)", n.d.,
              <https://csrc.nist.gov/pubs/sp/800/227/ipd>.

   [SP800-131Ar2]
              Barker, E., Roginksy, A., and National Institute of
              Standards and Technology (NIST), "Transitioning the Use of
              Cryptographic Algorithms and Key Lengths", n.d.,
              <https://nvlpubs.nist.gov/nistpubs/specialpublications/
              nist.sp.800-131ar2.pdf>.

   [X-Wing]   Barbosa, M., Connolly, D., Duarte, J., Kaiser, A.,
              Schwabe, P., Varner, K., and B. Westerbaan, "X-Wing The
              Hybrid KEM You’ve Been Looking For", 9 January 2024,
              <https://eprint.iacr.org/2024/039.pdf>.

Appendix A.  Maximum Key and Ciphertext Sizes

   The sizes listed below are maximum values: several factors could
   cause fluctuations in the size of the traditional component.  For
   example, this could be due to:

   *  Compressed vs uncompressed EC point.

   *  The RSA public key (n, e) allows e to vary is size between 3 and n
      - 1 [RFC8017].  Note that the size table below assumes the
      recommended value of e = 65537, so for RSA combinations it is in
      fact not a true maximum.

   *  When the underlying RSA or EC value is itself DER-encoded, integer
      values could occasionally be shorter than expected due to leading
      zeros being dropped from the encoding.

   By contrast, ML-KEM values are always fixed size, so composite values
   can always be correctly de-serialized based on the size of the ML-KEM
   component.

   Size values marked with an asterisk in the table are not fixed but
   maximum possible values for the composite key or ciphertext.
   Implementations MUST NOT perform strict length checking based on such
   values.

   Non-hybrid ML-KEM is included for reference.

   +=============================+========+=========+============+====+
   | Algorithm                   | Public | Private | Ciphertext | SS |
   |                             | key    | key     |            |    |
   +=============================+========+=========+============+====+
   | id-alg-ml-kem-768           | 1184   | 64      | 1088       | 32 |
   +-----------------------------+--------+---------+------------+----+
   | id-alg-ml-kem-1024          | 1568   | 64      | 1568       | 32 |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM768-RSA2048-HMAC-   | 1454*  | 1530*   | 1344       | 32 |
   | SHA256                      |        |         |            |    |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM768-RSA3072-HMAC-   | 1582*  | 2234*   | 1472       | 32 |
   | SHA256                      |        |         |            |    |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM768-RSA4096-HMAC-   | 1710*  | 2943*   | 1600       | 32 |
   | SHA256                      |        |         |            |    |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM768-X25519-SHA3-256 | 1216   | 132     | 1120       | 32 |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM768-ECDH-P256-HMAC- | 1249   | 170     | 1153       | 32 |
   | SHA256                      |        |         |            |    |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM768-ECDH-P384-HMAC- | 1281   | 218     | 1185       | 32 |
   | SHA256                      |        |         |            |    |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM768-ECDH-           | 1249   | 170     | 1153       | 32 |
   | brainpoolP256r1-HMAC-SHA256 |        |         |            |    |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM1024-RSA3072-HMAC-  | 1966*  | 2234*   | 1952       | 32 |
   | SHA512                      |        |         |            |    |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM1024-ECDH-P384-     | 1665   | 218     | 1665       | 32 |
   | HMAC-SHA512                 |        |         |            |    |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM1024-ECDH-          | 1665   | 218     | 1665       | 32 |
   | brainpoolP384r1-HMAC-SHA512 |        |         |            |    |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM1024-X448-SHA3-256  | 1624   | 180     | 1624       | 32 |
   +-----------------------------+--------+---------+------------+----+
   | id-MLKEM1024-ECDH-P521-     | 1701   | 272     | 1701       | 32 |
   | HMAC-SHA512                 |        |         |            |    |
   +-----------------------------+--------+---------+------------+----+

             Table 4: Maximum size values of composite ML-KEM

Appendix B.  Component Algorithm Reference

   This section provides references to the full specification of the
   algorithms used in the composite constructions.

      +================+========================+===================+
      | Component KEM  | OID                    | Specification     |
      | Algorithm ID   |                        |                   |
      +================+========================+===================+
      | id-ML-KEM-768  | 2.16.840.1.101.3.4.4.2 | [FIPS.203]        |
      +----------------+------------------------+-------------------+
      | id-ML-KEM-1024 | 2.16.840.1.101.3.4.4.3 | [FIPS.203]        |
      +----------------+------------------------+-------------------+
      | id-X25519      | 1.3.101.110            | [RFC7748],        |
      |                |                        | [RFC8410]         |
      +----------------+------------------------+-------------------+
      | id-X448        | 1.3.101.111            | [RFC7748],        |
      |                |                        | [RFC8410]         |
      +----------------+------------------------+-------------------+
      | id-ecDH        | 1.3.132.1.12           | [RFC5480],        |
      |                |                        | [RFC5915], [SEC1] |
      +----------------+------------------------+-------------------+
      | id-RSAES-OAEP  | 1.2.840.113549.1.1.7   | [RFC8017]         |
      +----------------+------------------------+-------------------+

         Table 5: Component Encryption Algorithms used in Composite
                               Constructions

     +==================+=======================+===================+
     | Elliptic CurveID | OID                   | Specification     |
     +==================+=======================+===================+
     | secp256r1        | 1.2.840.10045.3.1.7   | [RFC6090], [SEC2] |
     +------------------+-----------------------+-------------------+
     | secp384r1        | 1.3.132.0.34          | [RFC6090], [SEC2] |
     +------------------+-----------------------+-------------------+
     | secp521r1        | 1.3.132.0.35          | [RFC6090], [SEC2] |
     +------------------+-----------------------+-------------------+
     | brainpoolP256r1  | 1.3.36.3.3.2.8.1.1.7  | [RFC5639]         |
     +------------------+-----------------------+-------------------+
     | brainpoolP384r1  | 1.3.36.3.3.2.8.1.1.11 | [RFC5639]         |
     +------------------+-----------------------+-------------------+

         Table 6: Elliptic Curves used in Composite Constructions

         +=============+========================+===============+
         | HashID      | OID                    | Specification |
         +=============+========================+===============+
         | id-sha256   | 2.16.840.1.101.3.4.2.1 | [RFC6234]     |
         +-------------+------------------------+---------------+
         | id-sha512   | 2.16.840.1.101.3.4.2.3 | [RFC6234]     |
         +-------------+------------------------+---------------+
         | id-sha3-256 | 2.16.840.1.101.3.4.2.8 | [FIPS.202]    |
         +-------------+------------------------+---------------+

         Table 7: Hash algorithms used in Composite Constructions

Appendix C.  Fixed Component Algorithm Identifiers

   Many cryptographic libraries are X.509-focused and do not expose
   interfaces to instantiate a public key from raw bytes, but only from
   a SubjectPublicKeyInfo structure as you would find in an X.509
   certificate, therefore implementing composite in those libraries
   requires reconstructing the SPKI for each component algorithm.  In
   order to aid implementers and reduce interoperability issues, this
   section lists out the full public key and signature
   AlgorithmIdentifiers for each component algorithm.

   *ML-KEM-768*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-alg-ml-kem-768   -- (2.16.840.1.101.3.4.4.2)
       }

   DER:
     30 0B 06 07 60 86 48 01 65 03 04 04 02

   *ML-KEM-1024*

   ASN.1:

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-alg-ml-kem-1024   -- (2.16.840.1.101.3.4.4.3)
       }

   DER:
     30 0B 06 07 60 86 48 01 65 03 04 04 03

   *RSA-OAEP - all sizes*

 ASN.1:
   algorithm AlgorithmIdentifier ::= {
     algorithm id-RSAES-OAEP,   -- (1.2.840.113549.1.1.7)
     parameters RSAES-OAEP-params {
          hashFunc      [0] id-sha256,  -- (2.16.840.1.101.3.4.2.1)
          maskGenFunc   [1] mgf1SHA256Identifier,
          pSourceFunc   [2] pSpecifiedEmpty  }
     }


 where
       mgf1SHA256Identifier  AlgorithmIdentifier  ::=  {
                           algorithm id-mgf1,  -- (1.2.840.113549.1.1.8)
                           parameters sha256Identifier }


       sha256Identifier  AlgorithmIdentifier  ::=  { id-sha256, NULL }

 DER:
  30 4D 06 09 2A 86 48 86 F7 0D 01 01 07 30 40 A0 0F 30 0D 06 09 60 86
  48 01 65 03 04 02 01 05 00 A1 1C 30 1A 06 09 2A 86 48 86 F7 0D 01 01
  08 30 0D 06 09 60 86 48 01 65 03 04 02 01 05 00 A2 0F 30 0D 06 09 2A
  86 48 86 F7 0D 01 01 09 04 00

   *ECDH NIST-P-256*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ecPublicKey   -- (1.2.840.10045.2.1)
       parameters ANY ::= {
         AlgorithmIdentifier ::= {
           algorithm secp256r1    -- (1.2.840.10045.3.1.7)
           }
         }
       }

   DER:
     30 13 06 07 2A 86 48 CE 3D 02 01 06 08 2A 86 48 CE 3D 03 01 07

   *ECDH NIST-P-384*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ecPublicKey   -- (1.2.840.10045.2.1)
       parameters ANY ::= {
         AlgorithmIdentifier ::= {
           algorithm secp384r1    -- (1.3.132.0.34)
           }
         }
       }

   DER:
     30 10 06 07 2A 86 48 CE 3D 02 01 06 05 2B 81 04 00 22

   *ECDH NIST-P-521*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ecPublicKey   -- (1.2.840.10045.2.1)
       parameters ANY ::= {
         AlgorithmIdentifier ::= {
           algorithm secp521r1    -- (1.3.132.0.35)
           }
         }
       }

   DER:
     30 10 06 07 2A 86 48 CE 3D 02 01 06 05 2B 81 04 00 23

   *ECDH Brainpool-256*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ecPublicKey   -- (1.2.840.10045.2.1)
       parameters ANY ::= {
         AlgorithmIdentifier ::= {
           algorithm brainpoolP256r1   -- (1.3.36.3.3.2.8.1.1.7)
           }
         }
       }

   DER:
     30 14 06 07 2A 86 48 CE 3D 02 01 06 09 2B 24 03 03 02 08 01 01 07

   *ECDH Brainpool-384*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-ecPublicKey   -- (1.2.840.10045.2.1)
       parameters ANY ::= {
         AlgorithmIdentifier ::= {
           algorithm brainpoolP384r1   -- (1.3.36.3.3.2.8.1.1.11)
           }
         }
       }

   DER:
     30 14 06 07 2A 86 48 CE 3D 02 01 06 09 2B 24 03 03 02 08 01 01 0B

   *X25519*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-X25519   -- (1.3.101.110)
       }

   DER:
     30 05 06 03 2B 65 6E

   *X448*

   ASN.1:
     algorithm AlgorithmIdentifier ::= {
       algorithm id-X448   -- (1.3.101.111)
       }

   DER:
     30 05 06 03 2B 65 6F

Appendix D.  Comparison with other Hybrid KEMs

D.1.  X-Wing

   This specification borrows extensively from the analysis and KEM
   combiner construction presented in [X-Wing].  In particular, X-Wing
   and id-MLKEM768-X25519-SHA3-256 are largely interchangeable.  The one
   difference is that X-Wing uses a combined KeyGen function to generate
   the two component private keys from the same seed, which gives some
   additional binding properties.  However, using a derived value as the
   seed for ML-KEM.KeyGen_internal() is, at time of writing, explicitly
   disallowed by [FIPS.203] which makes it impossible to create a FIPS-
   compliant implementation of X-Wing's KeyGen or private key import
   functionality.  For this reason, this specification keeps the key
   generation for both components separate and only loosely-specified so
   that implementers are free to use an existing certified hardware or
   software module for one or both components.

   Due to the difference in key generation and security properties,
   X-Wing and id-MLKEM768-X25519-SHA3-256 have been registered as
   separate algorithms with separate OIDs, and they use a different KEM
   Combiner Label in order to ensure that their ciphertexts are not
   inter-compatible.

D.2.  ETSI CatKDF

   [ETSI.TS.103.744] section 8.2.3 defines CatKDF as:

  1) Form secret = psk || k1 || k 2.
  2) Set context = f(info, MA, MB), where f is a context formatting
     function.
  3) key_material = KDF(secret, label, context, length).
  4) Return key_material.

  MA shall contain all of the public keys.
  MB shall contain all of the corresponding public keys and ciphertexts.

   The main difference between the Composite ML-KEM combiner and the
   ETSI CatKDF combiner is that CatKDF makes the more conservative
   choice to bind the public keys and ciphertexts of both components,
   while Composite ML-KEM follows the analysis presented in [X-Wing]
   that while preserving the security properties of the traditional
   component requires binding the public key and ciphertext of the
   traditional component, it is not necessary to do so for ML-KEM thanks
   to the rejection sampling step of the Fujisaki-Okamoto transform.

   Additionally, ETSI CatKDF can be instantiated with either HMAC
   [RFC2104], KMAC [SP.800-185] or HKDF [RFC5869] as KDF.  Using HMAC
   aligns with some of the KDF variants in this specification, but not
   the ones that use SHA3 which do not have an equivalent construction
   of CatKDF.

Appendix E.  Examples of KEM Combiner Intermediate Values

   This section provides examples of constructing the input for the KEM
   Combiner, showing all intermediate values.  This is intended to be
   useful for debugging purposes.  See Section 4.4 for additional
   information.

   Each input component is shown.  Note that values are shown hex-
   encoded for display purposes only, they are actually raw binary
   values.

   *  mlkemSS is the shared secret produced by the ML-KEM encapsulate or
      decapsulate function which is always 32 bytes.

   *  tradSS is the shared secret produce by the traditional algorithm.

   *  tradCT is either an elliptic curve public key or an RSA-OAEP
      ciphertext depending on the algorithm chosen.

   *  tradPK is the public key of the traditional component (elliptic
      curve or RSA) and therefore fixed-length.

   *  Label is the specific KEM Combiner Label for this composite
      algorithm.  See Section 7

   Next, the Combined KDF Input is given, which is simply the
   concatenation of the above values.

   Finally, the KDF Function and the ss Output are shown as outputs.
   The ss is the Composite ML-KEM shared-secret generated by applying
   the KDF to the Combined KDF Input.

   Examples are given for each recommended Composite ML-KEM algorithm
   from Section 11.3, which happens to demonstrate all three combiner
   functions.

   Example 1:

  Example of id-MLKEM768-ECDH-P256-HMAC-SHA256 Combiner function output.

  # Inputs
  mlkemSS:
  4ee27059eaf3170b6bcd4a8838aaf8e24fdd4841152fc48fffb93ac34a38676e

  tradSS:
  e43f93569b159c06f09bb103471d235b62f70d272c3e09698fd2c0cf0fcfff00

  tradCT:  04f47b69e5f32c3178da607dc5cbd4508881024a4546f17f193a03d27ef5f
  38b619eb965e8a01a35468f10d268d2b5770520ebd19e35edd702adb6d3d2196bb3f7

  tradPK:  04430807c384f0555f457c524b2359cc6d0ee9d57b084a719534cbadb3e27
  d0f2ea9642b1edde16c9dc0f8eb1aaac2926b4f5fddc2d853a3f00e17c7009ffaa03e

  Label:  5153462d4d4c4b454d3736382d503235362d484d4143534841323536

          (ascii: "QSF-MLKEM768-P256-HMACSHA256")


  # Combined KDF Input:
  #  mlkemSS || tradSS || tradCT || tradPK || Label

  Combined KDF Input: 4ee27059eaf3170b6bcd4a8838aaf8e24fdd4841152fc48fff
  b93ac34a38676ee43f93569b159c06f09bb103471d235b62f70d272c3e09698fd2c0cf
  0fcfff0004f47b69e5f32c3178da607dc5cbd4508881024a4546f17f193a03d27ef5f3
  8b619eb965e8a01a35468f10d268d2b5770520ebd19e35edd702adb6d3d2196bb3f704
  430807c384f0555f457c524b2359cc6d0ee9d57b084a719534cbadb3e27d0f2ea9642b
  1edde16c9dc0f8eb1aaac2926b4f5fddc2d853a3f00e17c7009ffaa03eQSF-
  MLKEM768-P256-HMACSHA256


  # Outputs
  # ss = HMAC-SHA256(Combined KDF Input)

  ss: b8725d6dcbb4a544f83b9f6b36ee64ad79607b9a5517f93ddecf0167a2f75fad

   Example 2:

  Example of id-MLKEM768-X25519-SHA3-256 Combiner function output.

  # Inputs
  mlkemSS:
  6c79a318b19ea6a53fd30343f9344442d59cf8fce5caea4cca7f7bbbc85d666b

  tradSS:
  d1a38d455457a4926ca05b7706aa00a89314c09ba635e446b58df09046c68206

  tradCT:
  093a92e2d2cca58424176e49d9520e4f888054e0bf78cba6726f573573d1db4c

  tradPK:
  e55679d58ec4db4e08402346dcb0da6884497c4bfd58b22b4791d80a85d44b63
  Label:  5c2e2f2f5e5c

          (ascii: "\.//^\")


  # Combined KDF Input:
  #  mlkemSS || tradSS || tradCT || tradPK || Label

  Combined KDF Input: 6c79a318b19ea6a53fd30343f9344442d59cf8fce5caea4cca
  7f7bbbc85d666bd1a38d455457a4926ca05b7706aa00a89314c09ba635e446b58df090
  46c68206093a92e2d2cca58424176e49d9520e4f888054e0bf78cba6726f573573d1db
  4ce55679d58ec4db4e08402346dcb0da6884497c4bfd58b22b4791d80a85d44b63\.//
  ^\


  # Outputs
  # ss = SHA3-256(Combined KDF Input)

  ss: 6e1b2887fc0716a940883a1fba345af101d170f266b9a899318f128a5f90ea3a

   Example 3:

 Example of id-MLKEM1024-ECDH-P384-HMAC-SHA512 Combiner function output.

 # Inputs
 mlkemSS:
 59d3e414a6780a999c09fdaffd84849b00e78aede68df89ae89a55f13a6b74dc

 tradSS:  79c22be53d63c8dd321240df5c98735f2e5bb0a217cbef2e418d24ac727b0
 69f9ee790797287a56089e2b325201a13aa

 tradCT:  042e8b79e5dcedcbad166565b8a022ab5f1b4f7954779939ddaff9d67d95e
 450dbd680011a69d9c5b08dbb6cf9b646f9ebaf7c96128fd745cd4d33457b29f019517
 f8052858f0d54828136b95b81a1f86f5307b9dcdac32f98df9421c4bcdcd1a5

 tradPK:  0405e64b971c510a8260017725c53d7abb0a4828acae5547c66eec755c665
 f066e6aeedad3888360859629ab6431d69a949102a295df1ca6d9a90aba8a1a959dfe2
 ca3c6fff621a4d775ff0a6066809adca7fdd4450ce57ab33649727e1cb0ac23
 Label:  5153462d4d4c4b454d313032342d503338342d484d4143534841353132

         (ascii: "QSF-MLKEM1024-P384-HMACSHA512")


 # Combined KDF Input:
 #  mlkemSS || tradSS || tradCT || tradPK || Label

 Combined KDF Input: 59d3e414a6780a999c09fdaffd84849b00e78aede68df89ae8
 9a55f13a6b74dc79c22be53d63c8dd321240df5c98735f2e5bb0a217cbef2e418d24ac
 727b069f9ee790797287a56089e2b325201a13aa042e8b79e5dcedcbad166565b8a022
 ab5f1b4f7954779939ddaff9d67d95e450dbd680011a69d9c5b08dbb6cf9b646f9ebaf
 7c96128fd745cd4d33457b29f019517f8052858f0d54828136b95b81a1f86f5307b9dc
 dac32f98df9421c4bcdcd1a50405e64b971c510a8260017725c53d7abb0a4828acae55
 47c66eec755c665f066e6aeedad3888360859629ab6431d69a949102a295df1ca6d9a9
 0aba8a1a959dfe2ca3c6fff621a4d775ff0a6066809adca7fdd4450ce57ab33649727e
 1cb0ac23QSF-MLKEM1024-P384-HMACSHA512


 # Outputs
 # ss = HMAC-SHA512(Combined KDF Input)

 ss: ede40a6abfc02cb79fded6c0a0da554c0f60ede6cdc1b2bf2fec12102c3ee127

Appendix F.  Test Vectors

   The following test vectors are provided in a format similar to the
   NIST ACVP Known-Answer-Tests (KATs).

   The structure is that a global cacert is provided which is used to
   sign each KEM certificate.

   Within each test case there are the following values:

   *  tcId the name of the algorithm.

   *  ek the encapsulation public key.

   *  x5c the X.509 certificate of the encapsulation key, signed by the
      cacert.

   *  dk the raw decapsulation private key.

   *  dk_pkcs8 the decapsulation private key in a PKCS#8 object.

   *  c the ciphertext.

   *  k the derived shared secret key.

   Implementers should be able to perform the following tests using the
   test vectors below:

   1.  Load the public key ek or certificate x5c and perform an
       encapsulation for it (you should obtain valid ct and k values,
       but they will not match the ones in the test vector since Encap()
       is randomized.)

   2.  Load the decapsulation private key dk or dk_pkcs8 and the
       ciphertext c and perform a Decaps() operation to ensure that the
       same shared secret key k is derived.

   Test vectors are provided for each underlying ML-KEM algorithm in
   isolation for the purposes of debugging.

   Due to the length of the test vectors, some readers will prefer to
   retrieve the non-word-wrapped copy from GitHub.  The reference
   implementation written in python that generated them is also
   available.

   https://github.com/lamps-wg/draft-composite-kem/tree/main/src

   TODO: lock this to a specific commit.

... horrible merge conflict. I'm not fixing this by hand. I'll just commit and empty file and then re-run the automation.

Appendix G.  Intellectual Property Considerations

   The following IPR Disclosure relates to this draft:

   https://datatracker.ietf.org/ipr/3588/

Appendix H.  Contributors and Acknowledgments

   This document incorporates contributions and comments from a large
   group of experts.  The editors would especially like to acknowledge
   the expertise and tireless dedication of the following people, who
   attended many long meetings and generated millions of bytes of
   electronic mail and VOIP traffic over the past six years in pursuit
   of this document:

   Serge Mister (Entrust), Felipe Ventura (Entrust), Richard Kettlewell
   (Entrust), Ali Noman (Entrust), Peter C.  (UK NCSC), Tim Hollebeek
   (Digicert), Sophie Schmieg (Google), Deirdre Connolly (SandboxAQ),
   Chris A.  Wood (Apple), Bas Westerbaan (Cloudflare), Falko Strenzke
   (MTG AG), Piotr Popis (Enigma), Jean-Pierre Fiset (Crypto4A), 陳志華
   (Abel C.  H.  Chen, Chunghwa Telecom), 林邦曄 (Austin Lin, Chunghwa
   Telecom) and Douglas Stebila (University of Waterloo).

   Thanks to Giacomo Pope (github.com/GiacomoPope) whose ML-DSA and ML-
   KEM implementations were used to generate the test vectors.

   We wish to acknowledge particular effort from Carl Wallace and Dan
   van Geest (Crypto Next), who have put in sustained effort over
   multiple years both reviewing and implementing at the hackathon each
   iteration of this draft.

   Thanks to Stepan Yakimovich for contributing to the reference
   implementation.

   We are grateful to all who have given feedback over the years,
   formally or informally, on mailing lists or in person, including any
   contributors who may have been inadvertently omitted from this list.

   Finally, we wish to thank the authors of all the referenced documents
   upon which this specification was built.  "Copying always makes
   things easier and less error prone" - [RFC8411].

Authors' Addresses

   Mike Ounsworth
   Entrust Limited
   2500 Solandt Road – Suite 100
   Ottawa, Ontario  K2K 3G5
   Canada
   Email: mike.ounsworth@entrust.com


   John Gray
   Entrust Limited
   2500 Solandt Road – Suite 100
   Ottawa, Ontario  K2K 3G5
   Canada
   Email: john.gray@entrust.com


   Massimiliano Pala
   OpenCA Labs
   New York City, New York,
   United States of America
   Email: director@openca.org


   Jan Klaussner
   Bundesdruckerei GmbH
   Kommandantenstr. 18
   10969 Berlin
   Germany
   Email: jan.klaussner@bdr.de


   Scott Fluhrer
   Cisco Systems
   Email: sfluhrer@cisco.com
